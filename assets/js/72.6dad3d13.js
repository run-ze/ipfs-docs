(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{450:function(e,t,s){"use strict";s.r(t);var n=s(18),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"cli-commands"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cli-commands"}},[e._v("#")]),e._v(" CLI commands")]),e._v(" "),s("p",[e._v("This document is autogenerated from "),s("a",{attrs:{href:"https://github.com/ipfs-inactive/docs/blob/master/scripts/cli.sh",target:"_blank",rel:"noopener noreferrer"}},[e._v("cli.sh"),s("OutboundLink")],1),e._v(". For issues and support, check out the "),s("a",{attrs:{href:"https://github.com/ipfs/ipfs-docs",target:"_blank",rel:"noopener noreferrer"}},[e._v("docs repository"),s("OutboundLink")],1),e._v(" on GitHub.")]),e._v(" "),s("p",[s("em",[e._v("Generated on 2020-04-29 12:15:13, from go-ipfs 0.5.0.")])]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#ipfs"}},[e._v("ipfs")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-add"}},[e._v("ipfs add")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bitswap"}},[e._v("ipfs bitswap")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bitswap-ledger"}},[e._v("ipfs bitswap ledger")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bitswap-reprovide"}},[e._v("ipfs bitswap reprovide")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bitswap-stat"}},[e._v("ipfs bitswap stat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bitswap-wantlist"}},[e._v("ipfs bitswap wantlist")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-block"}},[e._v("ipfs block")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-block-get"}},[e._v("ipfs block get")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-block-put"}},[e._v("ipfs block put")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-block-rm"}},[e._v("ipfs block rm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-block-stat"}},[e._v("ipfs block stat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bootstrap"}},[e._v("ipfs bootstrap")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bootstrap-add"}},[e._v("ipfs bootstrap add")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bootstrap-add-default"}},[e._v("ipfs bootstrap add default")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bootstrap-list"}},[e._v("ipfs bootstrap list")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bootstrap-rm"}},[e._v("ipfs bootstrap rm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-bootstrap-rm-all"}},[e._v("ipfs bootstrap rm all")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cat"}},[e._v("ipfs cat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cid"}},[e._v("ipfs cid")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cid-base32"}},[e._v("ipfs cid base32")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cid-bases"}},[e._v("ipfs cid bases")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cid-codecs"}},[e._v("ipfs cid codecs")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cid-format"}},[e._v("ipfs cid format")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-cid-hashes"}},[e._v("ipfs cid hashes")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-commands"}},[e._v("ipfs commands")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-config"}},[e._v("ipfs config")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-config-edit"}},[e._v("ipfs config edit")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-config-profile"}},[e._v("ipfs config profile")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-config-profile-apply"}},[e._v("ipfs config profile apply")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-config-replace"}},[e._v("ipfs config replace")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-config-show"}},[e._v("ipfs config show")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-daemon"}},[e._v("ipfs daemon")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dag"}},[e._v("ipfs dag")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dag-export"}},[e._v("ipfs dag export")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dag-get"}},[e._v("ipfs dag get")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dag-import"}},[e._v("ipfs dag import")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dag-put"}},[e._v("ipfs dag put")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dag-resolve"}},[e._v("ipfs dag resolve")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht"}},[e._v("ipfs dht")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht-findpeer"}},[e._v("ipfs dht findpeer")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht-findprovs"}},[e._v("ipfs dht findprovs")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht-get"}},[e._v("ipfs dht get")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht-provide"}},[e._v("ipfs dht provide")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht-put"}},[e._v("ipfs dht put")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dht-query"}},[e._v("ipfs dht query")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-diag"}},[e._v("ipfs diag")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-diag-cmds"}},[e._v("ipfs diag cmds")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-diag-cmds-clear"}},[e._v("ipfs diag cmds clear")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-diag-cmds-set-time"}},[e._v("ipfs diag cmds set-time")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-diag-sys"}},[e._v("ipfs diag sys")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-dns"}},[e._v("ipfs dns")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-file"}},[e._v("ipfs file")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-file-ls"}},[e._v("ipfs file ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files"}},[e._v("ipfs files")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-chcid"}},[e._v("ipfs files chcid")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-cp"}},[e._v("ipfs files cp")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-flush"}},[e._v("ipfs files flush")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-ls"}},[e._v("ipfs files ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-mkdir"}},[e._v("ipfs files mkdir")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-mv"}},[e._v("ipfs files mv")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-read"}},[e._v("ipfs files read")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-rm"}},[e._v("ipfs files rm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-stat"}},[e._v("ipfs files stat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-files-write"}},[e._v("ipfs files write")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-filestore"}},[e._v("ipfs filestore")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-filestore-dups"}},[e._v("ipfs filestore dups")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-filestore-ls"}},[e._v("ipfs filestore ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-filestore-verify"}},[e._v("ipfs filestore verify")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-get"}},[e._v("ipfs get")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-id"}},[e._v("ipfs id")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-init"}},[e._v("ipfs init")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-key"}},[e._v("ipfs key")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-key-gen"}},[e._v("ipfs key gen")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-key-list"}},[e._v("ipfs key list")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-key-rename"}},[e._v("ipfs key rename")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-key-rm"}},[e._v("ipfs key rm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-log"}},[e._v("ipfs log")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-log-level"}},[e._v("ipfs log level")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-log-ls"}},[e._v("ipfs log ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-log-tail"}},[e._v("ipfs log tail")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-ls"}},[e._v("ipfs ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-mount"}},[e._v("ipfs mount")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name"}},[e._v("ipfs name")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name-publish"}},[e._v("ipfs name publish")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name-pubsub"}},[e._v("ipfs name pubsub")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name-pubsub-cancel"}},[e._v("ipfs name pubsub cancel")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name-pubsub-state"}},[e._v("ipfs name pubsub state")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name-pubsub-subs"}},[e._v("ipfs name pubsub subs")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-name-resolve"}},[e._v("ipfs name resolve")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object"}},[e._v("ipfs object")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-data"}},[e._v("ipfs object data")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-diff"}},[e._v("ipfs object diff")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-get"}},[e._v("ipfs object get")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-links"}},[e._v("ipfs object links")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-new"}},[e._v("ipfs object new")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-patch"}},[e._v("ipfs object patch")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-patch-add-link"}},[e._v("ipfs object patch add-link")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-patch-append-data"}},[e._v("ipfs object patch append-data")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-patch-rm-link"}},[e._v("ipfs object patch rm-link")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-patch-set-data"}},[e._v("ipfs object patch set-data")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-put"}},[e._v("ipfs object put")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-object-stat"}},[e._v("ipfs object stat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p"}},[e._v("ipfs p2p")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-close"}},[e._v("ipfs p2p close")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-forward"}},[e._v("ipfs p2p forward")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-listen"}},[e._v("ipfs p2p listen")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-ls"}},[e._v("ipfs p2p ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-stream"}},[e._v("ipfs p2p stream")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-stream-close"}},[e._v("ipfs p2p stream close")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-p2p-stream-ls"}},[e._v("ipfs p2p stream ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pin"}},[e._v("ipfs pin")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pin-add"}},[e._v("ipfs pin add")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pin-ls"}},[e._v("ipfs pin ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pin-rm"}},[e._v("ipfs pin rm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pin-update"}},[e._v("ipfs pin update")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pin-verify"}},[e._v("ipfs pin verify")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-ping"}},[e._v("ipfs ping")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pubsub"}},[e._v("ipfs pubsub")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pubsub-ls"}},[e._v("ipfs pubsub ls")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pubsub-peers"}},[e._v("ipfs pubsub peers")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pubsub-pub"}},[e._v("ipfs pubsub pub")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-pubsub-sub"}},[e._v("ipfs pubsub sub")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-refs"}},[e._v("ipfs refs")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-refs-local"}},[e._v("ipfs refs local")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-repo"}},[e._v("ipfs repo")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-repo-fsck"}},[e._v("ipfs repo fsck")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-repo-gc"}},[e._v("ipfs repo gc")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-repo-stat"}},[e._v("ipfs repo stat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-repo-verify"}},[e._v("ipfs repo verify")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-repo-version"}},[e._v("ipfs repo version")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-resolve"}},[e._v("ipfs resolve")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-shutdown"}},[e._v("ipfs shutdown")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-stats"}},[e._v("ipfs stats")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-stats-bitswap"}},[e._v("ipfs stats bitswap")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-stats-bw"}},[e._v("ipfs stats bw")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-stats-repo"}},[e._v("ipfs stats repo")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm"}},[e._v("ipfs swarm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-addrs"}},[e._v("ipfs swarm addrs")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-addrs-listen"}},[e._v("ipfs swarm addrs listen")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-addrs-local"}},[e._v("ipfs swarm addrs local")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-connect"}},[e._v("ipfs swarm connect")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-disconnect"}},[e._v("ipfs swarm disconnect")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-filters"}},[e._v("ipfs swarm filters")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-filters-add"}},[e._v("ipfs swarm filters add")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-filters-rm"}},[e._v("ipfs swarm filters rm")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-swarm-peers"}},[e._v("ipfs swarm peers")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-tar"}},[e._v("ipfs tar")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-tar-add"}},[e._v("ipfs tar add")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-tar-cat"}},[e._v("ipfs tar cat")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-update"}},[e._v("ipfs update")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-urlstore"}},[e._v("ipfs urlstore")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-urlstore-add"}},[e._v("ipfs urlstore add")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-version"}},[e._v("ipfs version")])]),e._v(" "),s("li",[s("a",{attrs:{href:"#ipfs-version-deps"}},[e._v("ipfs version deps")])])]),e._v(" "),s("h2",{attrs:{id:"ipfs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs"}},[e._v("#")]),e._v(" ipfs")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs  - Global p2p merkle-dag filesystem.\n\nSYNOPSIS\n  ipfs [--config=<config> | -c] [--debug | -D] [--help] [-h] [--api=<api>] [--offline] [--cid-base=<base>] [--upgrade-cidv0-in-output] [--encoding=<encoding> | --enc] [--timeout=<timeout>] <command> ...\n\nOPTIONS\n\n  -c, --config               string - Path to the configuration file to use.\n  -D, --debug                bool   - Operate in debug mode.\n  --help                     bool   - Show the full command help text.\n  -h                         bool   - Show a short version of the command help\n                                      text.\n  -L, --local                bool   - Run the command locally, instead of using\n                                      the daemon. DEPRECATED: use --offline.\n  --offline                  bool   - Run the command offline.\n  --api                      string - Use a specific API instance (defaults to\n                                      /ip4/127.0.0.1/tcp/5001).\n  --cid-base                 string - Multibase encoding used for version 1\n                                      CIDs in output.\n  --upgrade-cidv0-in-output  bool   - Upgrade version 0 to version 1 CIDs in\n                                      output.\n  --enc, --encoding          string - The encoding type the output should be\n                                      encoded with (json, xml, or text).\n                                      Default: text.\n  --stream-channels          bool   - Stream channel output.\n  --timeout                  string - Set a global timeout on the command.\n\nSUBCOMMANDS\n  BASIC COMMANDS\n    init          Initialize ipfs local configuration\n    add <path>    Add a file to IPFS\n    cat <ref>     Show IPFS object data\n    get <ref>     Download IPFS objects\n    ls <ref>      List links from an object\n    refs <ref>    List hashes of links from an object\n  \n  DATA STRUCTURE COMMANDS\n    block         Interact with raw blocks in the datastore\n    object        Interact with raw dag nodes\n    files         Interact with objects as if they were a unix filesystem\n    dag           Interact with IPLD documents (experimental)\n  \n  ADVANCED COMMANDS\n    daemon        Start a long-running daemon process\n    mount         Mount an IPFS read-only mountpoint\n    resolve       Resolve any type of name\n    name          Publish and resolve IPNS names\n    key           Create and list IPNS name keypairs\n    dns           Resolve DNS links\n    pin           Pin objects to local storage\n    repo          Manipulate the IPFS repository\n    stats         Various operational stats\n    p2p           Libp2p stream mounting\n    filestore     Manage the filestore (experimental)\n  \n  NETWORK COMMANDS\n    id            Show info about IPFS peers\n    bootstrap     Add or remove bootstrap peers\n    swarm         Manage connections to the p2p network\n    dht           Query the DHT for values or peers\n    ping          Measure the latency of a connection\n    diag          Print diagnostics\n  \n  TOOL COMMANDS\n    config        Manage configuration\n    version       Show ipfs version information\n    update        Download and apply go-ipfs updates\n    commands      List all available commands\n    cid           Convert and discover properties of CIDs\n    log           Manage and show logs of running daemon\n  \n  Use 'ipfs <command> --help' to learn more about each command.\n  \n  ipfs uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n    export IPFS_PATH=/path/to/ipfsrepo\n  \n  EXIT STATUS\n  \n  The CLI will exit with one of the following values:\n  \n  0     Successful execution.\n  1     Failed executions.\n\n  For more information about each command, use:\n  'ipfs <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-add"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-add"}},[e._v("#")]),e._v(" ipfs add")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs add <path>... - Add a file or directory to ipfs.\n\nSYNOPSIS\n  ipfs add [--recursive | -r] [--dereference-args] [--stdin-name=<stdin-name>]\n           [--hidden | -H] [--ignore=<ignore>]...\n           [--ignore-rules-path=<ignore-rules-path>] [--quiet | -q]\n           [--quieter | -Q] [--silent] [--progress | -p] [--trickle | -t]\n           [--only-hash | -n] [--wrap-with-directory | -w]\n           [--chunker=<chunker> | -s] [--pin=false] [--raw-leaves] [--nocopy]\n           [--fscache] [--cid-version=<cid-version>] [--hash=<hash>] [--inline]\n           [--inline-limit=<inline-limit>] [--] <path>...\n\nARGUMENTS\n\n  <path>... - The path to a file to be added to ipfs.\n\nOPTIONS\n\n  -r, --recursive            bool   - Add directory paths recursively.\n  --dereference-args         bool   - Symlinks supplied in arguments are\n                                      dereferenced.\n  --stdin-name               string - Assign a name if the file source is stdin.\n  -H, --hidden               bool   - Include files that are hidden. Only takes\n                                      effect on recursive add.\n  --ignore                   array  - A rule (.gitignore-stype) defining which\n                                      file(s) should be ignored (variadic,\n                                      experimental).\n  --ignore-rules-path        string - A path to a file with .gitignore-style\n                                      ignore rules (experimental).\n  -q, --quiet                bool   - Write minimal output.\n  -Q, --quieter              bool   - Write only final hash.\n  --silent                   bool   - Write no output.\n  -p, --progress             bool   - Stream progress data.\n  -t, --trickle              bool   - Use trickle-dag format for dag generation.\n  -n, --only-hash            bool   - Only chunk and hash - do not write to\n                                      disk.\n  -w, --wrap-with-directory  bool   - Wrap files with a directory object.\n  -s, --chunker              string - Chunking algorithm, size-[bytes],\n                                      rabin-[min]-[avg]-[max] or buzhash.\n                                      Default: size-262144.\n  --pin                      bool   - Pin this object when adding. Default:\n                                      true.\n  --raw-leaves               bool   - Use raw blocks for leaf nodes.\n                                      (experimental).\n  --nocopy                   bool   - Add the file using filestore. Implies\n                                      raw-leaves. (experimental).\n  --fscache                  bool   - Check the filestore for pre-existing\n                                      blocks. (experimental).\n  --cid-version              int    - CID version. Defaults to 0 unless an\n                                      option that depends on CIDv1 is passed.\n                                      (experimental).\n  --hash                     string - Hash function to use. Implies CIDv1 if\n                                      not sha2-256. (experimental). Default:\n                                      sha2-256.\n  --inline                   bool   - Inline small blocks into CIDs.\n                                      (experimental).\n  --inline-limit             int    - Maximum block size to inline.\n                                      (experimental). Default: 32.\n\nDESCRIPTION\n\n  Adds contents of <path> to ipfs. Use -r to add directories.\n  Note that directories are added recursively, to form the ipfs\n  MerkleDAG.\n  \n  The wrap option, '-w', wraps the file (or files, if using the\n  recursive option) in a directory. This directory contains only\n  the files which have been added, and means that the file retains\n  its filename. For example:\n  \n    > ipfs add example.jpg\n    added QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH example.jpg\n    > ipfs add example.jpg -w\n    added QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH example.jpg\n    added QmaG4FuMqEBnQNn3C8XJ5bpW8kLs7zq2ZXgHptJHbKDDVx\n  \n  You can now refer to the added file in a gateway, like so:\n  \n    /ipfs/QmaG4FuMqEBnQNn3C8XJ5bpW8kLs7zq2ZXgHptJHbKDDVx/example.jpg\n  \n  The chunker option, '-s', specifies the chunking strategy that dictates\n  how to break files into blocks. Blocks with same content can\n  be deduplicated. Different chunking strategies will produce different\n  hashes for the same file. The default is a fixed block size of\n  256 * 1024 bytes, 'size-262144'. Alternatively, you can use the\n  Buzhash or Rabin fingerprint chunker for content defined chunking by\n  specifying buzhash or rabin-[min]-[avg]-[max] (where min/avg/max refer\n  to the desired chunk sizes in bytes), e.g. 'rabin-262144-524288-1048576'.\n  \n  The following examples use very small byte sizes to demonstrate the\n  properties of the different chunkers on a small file. You'll likely\n  want to use a 1024 times larger chunk sizes for most files.\n  \n    > ipfs add --chunker=size-2048 ipfs-logo.svg\n    added QmafrLBfzRLV4XSH1XcaMMeaXEUhDJjmtDfsYU95TrWG87 ipfs-logo.svg\n    > ipfs add --chunker=rabin-512-1024-2048 ipfs-logo.svg\n    added Qmf1hDN65tR55Ubh2RN1FPxr69xq3giVBz1KApsresY8Gn ipfs-logo.svg\n  \n  You can now check what blocks have been created by:\n  \n    > ipfs object links QmafrLBfzRLV4XSH1XcaMMeaXEUhDJjmtDfsYU95TrWG87\n    QmY6yj1GsermExDXoosVE3aSPxdMNYr6aKuw3nA8LoWPRS 2059\n    Qmf7ZQeSxq2fJVJbCmgTrLLVN9tDR9Wy5k75DxQKuz5Gyt 1195\n    > ipfs object links Qmf1hDN65tR55Ubh2RN1FPxr69xq3giVBz1KApsresY8Gn\n    QmY6yj1GsermExDXoosVE3aSPxdMNYr6aKuw3nA8LoWPRS 2059\n    QmerURi9k4XzKCaaPbsK6BL5pMEjF7PGphjDvkkjDtsVf3 868\n    QmQB28iwSriSUSMqG2nXDTLtdPHgWb4rebBrU7Q1j4vxPv 338\n  \n  Finally, a note on hash determinism. While not guaranteed, adding the same\n  file/directory with the same flags will almost always result in the same output\n  hash. However, almost all of the flags provided by this command (other than pin,\n  only-hash, and progress/status related flags) will change the final hash.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bitswap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bitswap"}},[e._v("#")]),e._v(" ipfs bitswap")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bitswap - Interact with the bitswap agent.\n\nSYNOPSIS\n  ipfs bitswap\n\nSUBCOMMANDS\n  ipfs bitswap ledger <peer> - Show the current ledger for a peer.\n  ipfs bitswap reprovide     - Trigger reprovider.\n  ipfs bitswap stat          - Show some diagnostic information on the bitswap\n                               agent.\n  ipfs bitswap wantlist      - Show blocks currently on the wantlist.\n\n  For more information about each command, use:\n  'ipfs bitswap <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-bitswap-ledger"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bitswap-ledger"}},[e._v("#")]),e._v(" ipfs bitswap ledger")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bitswap ledger <peer> - Show the current ledger for a peer.\n\nSYNOPSIS\n  ipfs bitswap ledger [--] <peer>\n\nARGUMENTS\n\n  <peer> - The PeerID (B58) of the ledger to inspect.\n\nDESCRIPTION\n\n  The Bitswap decision engine tracks the number of bytes exchanged between IPFS\n  nodes, and stores this information as a collection of ledgers. This command\n  prints the ledger associated with a given peer.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bitswap-reprovide"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bitswap-reprovide"}},[e._v("#")]),e._v(" ipfs bitswap reprovide")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bitswap reprovide - Trigger reprovider.\n\nSYNOPSIS\n  ipfs bitswap reprovide\n\nDESCRIPTION\n\n  Trigger reprovider to announce our data to network.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bitswap-stat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bitswap-stat"}},[e._v("#")]),e._v(" ipfs bitswap stat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bitswap stat - Show some diagnostic information on the bitswap agent.\n\nSYNOPSIS\n  ipfs bitswap stat [--verbose | -v] [--human]\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n  --human        bool - Print sizes in human readable format (e.g., 1K 234M 2G).\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bitswap-wantlist"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bitswap-wantlist"}},[e._v("#")]),e._v(" ipfs bitswap wantlist")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bitswap wantlist - Show blocks currently on the wantlist.\n\nSYNOPSIS\n  ipfs bitswap wantlist [--peer=<peer> | -p]\n\nOPTIONS\n\n  -p, --peer  string - Specify which peer to show wantlist for. Default: self.\n\nDESCRIPTION\n\n  Print out all blocks currently on the bitswap wantlist for the local peer.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-block"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-block"}},[e._v("#")]),e._v(" ipfs block")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs block - Interact with raw IPFS blocks.\n\nSYNOPSIS\n  ipfs block\n\nDESCRIPTION\n\n  'ipfs block' is a plumbing command used to manipulate raw IPFS blocks.\n  Reads from stdin or writes to stdout, and <key> is a base58 encoded\n  multihash.\n\nSUBCOMMANDS\n  ipfs block get <key>     - Get a raw IPFS block.\n  ipfs block put <data>... - Store input as an IPFS block.\n  ipfs block rm <hash>...  - Remove IPFS block(s).\n  ipfs block stat <key>    - Print information of a raw IPFS block.\n\n  For more information about each command, use:\n  'ipfs block <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-block-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-block-get"}},[e._v("#")]),e._v(" ipfs block get")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs block get <key> - Get a raw IPFS block.\n\nSYNOPSIS\n  ipfs block get [--] <key>\n\nARGUMENTS\n\n  <key> - The base58 multihash of an existing block to get.\n\nDESCRIPTION\n\n  'ipfs block get' is a plumbing command for retrieving raw IPFS blocks.\n  It outputs to stdout, and <key> is a base58 encoded multihash.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-block-put"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-block-put"}},[e._v("#")]),e._v(" ipfs block put")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs block put <data>... - Store input as an IPFS block.\n\nSYNOPSIS\n  ipfs block put [--format=<format> | -f] [--mhtype=<mhtype>] [--mhlen=<mhlen>]\n                 [--pin] [--] <data>...\n\nARGUMENTS\n\n  <data>... - The data to be stored as an IPFS block.\n\nOPTIONS\n\n  -f, --format  string - cid format for blocks to be created with.\n  --mhtype      string - multihash hash function. Default: sha2-256.\n  --mhlen       int    - multihash hash length. Default: -1.\n  --pin         bool   - pin added blocks recursively. Default: false.\n\nDESCRIPTION\n\n  'ipfs block put' is a plumbing command for storing raw IPFS blocks.\n  It reads from stdin, and outputs the block's CID to stdout.\n  \n  Unless specified, this command returns dag-pb CIDv0 CIDs. Setting 'mhtype' to anything\n  other than 'sha2-256' or format to anything other than 'v0' will result in CIDv1.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-block-rm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-block-rm"}},[e._v("#")]),e._v(" ipfs block rm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs block rm <hash>... - Remove IPFS block(s).\n\nSYNOPSIS\n  ipfs block rm [--force | -f] [--quiet | -q] [--] <hash>...\n\nARGUMENTS\n\n  <hash>... - Bash58 encoded multihash of block(s) to remove.\n\nOPTIONS\n\n  -f, --force  bool - Ignore nonexistent blocks.\n  -q, --quiet  bool - Write minimal output.\n\nDESCRIPTION\n\n  'ipfs block rm' is a plumbing command for removing raw ipfs blocks.\n  It takes a list of base58 encoded multihashes to remove.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-block-stat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-block-stat"}},[e._v("#")]),e._v(" ipfs block stat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs block stat <key> - Print information of a raw IPFS block.\n\nSYNOPSIS\n  ipfs block stat [--] <key>\n\nARGUMENTS\n\n  <key> - The base58 multihash of an existing block to stat.\n\nDESCRIPTION\n\n  'ipfs block stat' is a plumbing command for retrieving information\n  on raw IPFS blocks. It outputs the following to stdout:\n  \n  \tKey  - the base58 encoded multihash\n  \tSize - the size of the block in bytes\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bootstrap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bootstrap"}},[e._v("#")]),e._v(" ipfs bootstrap")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bootstrap - Show or edit the list of bootstrap peers.\n\nSYNOPSIS\n  ipfs bootstrap\n\nDESCRIPTION\n\n  Running 'ipfs bootstrap' with no arguments will run 'ipfs bootstrap list'.\n  \n  SECURITY WARNING:\n  \n  The bootstrap command manipulates the \"bootstrap list\", which contains\n  the addresses of bootstrap nodes. These are the *trusted peers* from\n  which to learn about other peers in the network. Only edit this list\n  if you understand the risks of adding or removing nodes from this list.\n\nSUBCOMMANDS\n  ipfs bootstrap add [<peer>]... - Add peers to the bootstrap list.\n  ipfs bootstrap list            - Show peers in the bootstrap list.\n  ipfs bootstrap rm [<peer>]...  - Remove peers from the bootstrap list.\n\n  For more information about each command, use:\n  'ipfs bootstrap <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-bootstrap-add"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bootstrap-add"}},[e._v("#")]),e._v(" ipfs bootstrap add")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bootstrap add [<peer>]... - Add peers to the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap add [--default] [--] [<peer>...]\n\nARGUMENTS\n\n  [<peer>]... - A peer to add to the bootstrap list (in the format\n                '<multiaddr>/<peerID>')\n\nOPTIONS\n\n  --default  bool - Add default bootstrap nodes. (Deprecated, use 'default'\n                    subcommand instead).\n\nDESCRIPTION\n\n  Outputs a list of peers that were added (that weren't already\n  in the bootstrap list).\n  \n  SECURITY WARNING:\n  \n  The bootstrap command manipulates the \"bootstrap list\", which contains\n  the addresses of bootstrap nodes. These are the *trusted peers* from\n  which to learn about other peers in the network. Only edit this list\n  if you understand the risks of adding or removing nodes from this list.\n\nSUBCOMMANDS\n  ipfs bootstrap add default - Add default peers to the bootstrap list.\n\n  For more information about each command, use:\n  'ipfs bootstrap add <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-bootstrap-add-default"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bootstrap-add-default"}},[e._v("#")]),e._v(" ipfs bootstrap add default")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bootstrap add default - Add default peers to the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap add default\n\nDESCRIPTION\n\n  Outputs a list of peers that were added (that weren't already\n  in the bootstrap list).\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bootstrap-list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bootstrap-list"}},[e._v("#")]),e._v(" ipfs bootstrap list")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bootstrap list - Show peers in the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap list\n\nDESCRIPTION\n\n  Peers are output in the format '<multiaddr>/<peerID>'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-bootstrap-rm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bootstrap-rm"}},[e._v("#")]),e._v(" ipfs bootstrap rm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bootstrap rm [<peer>]... - Remove peers from the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap rm [--all] [--] [<peer>...]\n\nARGUMENTS\n\n  [<peer>]... - A peer to add to the bootstrap list (in the format\n                '<multiaddr>/<peerID>')\n\nOPTIONS\n\n  --all  bool - Remove all bootstrap peers. (Deprecated, use 'all' subcommand).\n\nDESCRIPTION\n\n  Outputs the list of peers that were removed.\n  \n  SECURITY WARNING:\n  \n  The bootstrap command manipulates the \"bootstrap list\", which contains\n  the addresses of bootstrap nodes. These are the *trusted peers* from\n  which to learn about other peers in the network. Only edit this list\n  if you understand the risks of adding or removing nodes from this list.\n\nSUBCOMMANDS\n  ipfs bootstrap rm all - Remove all peers from the bootstrap list.\n\n  For more information about each command, use:\n  'ipfs bootstrap rm <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-bootstrap-rm-all"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-bootstrap-rm-all"}},[e._v("#")]),e._v(" ipfs bootstrap rm all")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs bootstrap rm all - Remove all peers from the bootstrap list.\n\nSYNOPSIS\n  ipfs bootstrap rm all\n\nDESCRIPTION\n\n  Outputs the list of peers that were removed.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-cat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cat"}},[e._v("#")]),e._v(" ipfs cat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cat <ipfs-path>... - Show IPFS object data.\n\nSYNOPSIS\n  ipfs cat [--offset=<offset> | -o] [--length=<length> | -l] [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - The path to the IPFS object(s) to be outputted.\n\nOPTIONS\n\n  -o, --offset  int64 - Byte offset to begin reading from.\n  -l, --length  int64 - Maximum number of bytes to read.\n\nDESCRIPTION\n\n  Displays the data contained by an IPFS or IPNS object(s) at the given path.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-cid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cid"}},[e._v("#")]),e._v(" ipfs cid")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cid - Convert and discover properties of CIDs\n\nSYNOPSIS\n  ipfs cid\n\nSUBCOMMANDS\n  ipfs cid base32 <cid>... - Convert CIDs to Base32 CID version 1.\n  ipfs cid bases           - List available multibase encodings.\n  ipfs cid codecs          - List available CID codecs.\n  ipfs cid format <cid>... - Format and convert a CID in various useful ways.\n  ipfs cid hashes          - List available multihashes.\n\n  For more information about each command, use:\n  'ipfs cid <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-cid-base32"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cid-base32"}},[e._v("#")]),e._v(" ipfs cid base32")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cid base32 <cid>... - Convert CIDs to Base32 CID version 1.\n\nSYNOPSIS\n  ipfs cid base32 [--] <cid>...\n\nARGUMENTS\n\n  <cid>... - Cids to convert.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-cid-bases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cid-bases"}},[e._v("#")]),e._v(" ipfs cid bases")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cid bases - List available multibase encodings.\n\nSYNOPSIS\n  ipfs cid bases [--prefix] [--numeric]\n\nOPTIONS\n\n  --prefix   bool - also include the single letter prefixes in addition to the\n                    code.\n  --numeric  bool - also include numeric codes.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-cid-codecs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cid-codecs"}},[e._v("#")]),e._v(" ipfs cid codecs")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cid codecs - List available CID codecs.\n\nSYNOPSIS\n  ipfs cid codecs [--numeric]\n\nOPTIONS\n\n  --numeric  bool - also include numeric codes.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-cid-format"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cid-format"}},[e._v("#")]),e._v(" ipfs cid format")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cid format <cid>... - Format and convert a CID in various useful ways.\n\nSYNOPSIS\n  ipfs cid format [-f=<f>] [-v=<v>] [--codec=<codec>] [-b=<b>] [--] <cid>...\n\nARGUMENTS\n\n  <cid>... - Cids to format.\n\nOPTIONS\n\n  -f       string - Printf style format string. Default: %s.\n  -v       string - CID version to convert to.\n  --codec  string - CID codec to convert to.\n  -b       string - Multibase to display CID in.\n\nDESCRIPTION\n\n  Format and converts <cid>'s in various useful ways.\n  \n  The optional format string is a printf style format string:\n  \n     %% literal %\n     %b multibase name\n     %B multibase code\n     %v version string\n     %V version number\n     %c codec name\n     %C codec code\n     %h multihash name\n     %H multihash code\n     %L hash digest length\n     %m multihash encoded in base %b (with multibase prefix)\n     %M multihash encoded in base %b without multibase prefix\n     %d hash digest encoded in base %b (with multibase prefix)\n     %D hash digest encoded in base %b without multibase prefix\n     %s cid string encoded in base %b (1)\n     %S cid string encoded in base %b without multibase prefix\n     %P cid prefix: %v-%c-%h-%L\n  \n  (1) For CID version 0 the multibase must be base58btc and no prefix is\n  used.  For Cid version 1 the multibase prefix is included.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-cid-hashes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-cid-hashes"}},[e._v("#")]),e._v(" ipfs cid hashes")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs cid hashes - List available multihashes.\n\nSYNOPSIS\n  ipfs cid hashes [--numeric]\n\nOPTIONS\n\n  --numeric  bool - also include numeric codes.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-commands"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-commands"}},[e._v("#")]),e._v(" ipfs commands")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs commands - List all available commands.\n\nSYNOPSIS\n  ipfs commands [--flags | -f]\n\nOPTIONS\n\n  -f, --flags  bool - Show command flags.\n\nDESCRIPTION\n\n  Lists all available commands (and subcommands) and exits.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-config"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-config"}},[e._v("#")]),e._v(" ipfs config")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs config <key> [<value>] - Get and set ipfs config values.\n\nSYNOPSIS\n  ipfs config [--bool] [--json] [--] <key> [<value>]\n\nARGUMENTS\n\n  <key>     - The key of the config entry (e.g. \"Addresses.API\").\n  [<value>] - The value to set the config entry to.\n\nOPTIONS\n\n  --bool  bool - Set a boolean value.\n  --json  bool - Parse stringified JSON.\n\nDESCRIPTION\n\n  'ipfs config' controls configuration variables. It works\n  much like 'git config'. The configuration values are stored in a config\n  file inside your IPFS repository.\n  \n  Examples:\n  \n  Get the value of the 'Datastore.Path' key:\n  \n    $ ipfs config Datastore.Path\n  \n  Set the value of the 'Datastore.Path' key:\n  \n    $ ipfs config Datastore.Path ~/.ipfs/datastore\n\nSUBCOMMANDS\n  ipfs config edit           - Open the config file for editing in $EDITOR.\n  ipfs config profile        - Apply profiles to config.\n  ipfs config replace <file> - Replace the config with <file>.\n  ipfs config show           - Output config file contents.\n\n  For more information about each command, use:\n  'ipfs config <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-config-edit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-config-edit"}},[e._v("#")]),e._v(" ipfs config edit")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs config edit - Open the config file for editing in $EDITOR.\n\nSYNOPSIS\n  ipfs config edit\n\nDESCRIPTION\n\n  To use 'ipfs config edit', you must have the $EDITOR environment\n  variable set to your preferred text editor.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-config-profile"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-config-profile"}},[e._v("#")]),e._v(" ipfs config profile")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs config profile - Apply profiles to config.\n\nSYNOPSIS\n  ipfs config profile\n\nDESCRIPTION\n\n  Available profiles:\n    'default-datastore':\n      Configures the node to use the default datastore (flatfs).\n      \n      Read the \"flatfs\" profile description for more information on this datastore.\n      \n      This profile may only be applied when first initializing the node.\n      \n    'flatfs':\n      Configures the node to use the flatfs datastore.\n      \n      This is the most battle-tested and reliable datastore, but it's significantly\n      slower than the badger datastore. You should use this datastore if:\n      \n      * You need a very simple and very reliable datastore you and trust your\n        filesystem. This datastore stores each block as a separate file in the\n        underlying filesystem so it's unlikely to loose data unless there's an issue\n        with the underlying file system.\n      * You need to run garbage collection on a small (<= 10GiB) datastore. The\n        default datastore, badger, can leave several gigabytes of data behind when\n        garbage collecting.\n      * You're concerned about memory usage. In its default configuration, badger can\n        use up to several gigabytes of memory.\n      \n      This profile may only be applied when first initializing the node.\n      \n    'badgerds':\n      Configures the node to use the badger datastore.\n      \n      This is the fastest datastore. Use this datastore if performance, especially\n      when adding many gigabytes of files, is critical. However:\n      \n      * This datastore will not properly reclaim space when your datastore is\n        smaller than several gigabytes. If you run IPFS with '--enable-gc' (you have\n        enabled block-level garbage collection), you plan on storing very little data in\n        your IPFS node, and disk usage is more critical than performance, consider using\n        flatfs.\n      * This datastore uses up to several gigabytes of memory. \n      \n      This profile may only be applied when first initializing the node.\n    'lowpower':\n      Reduces daemon overhead on the system. May affect node\n      functionality - performance of content discovery and data\n      fetching may be degraded.\n      \n    'randomports':\n      Use a random port number for swarm.\n    'server':\n      Disables local host discovery, recommended when\n      running IPFS on machines with public IPv4 addresses.\n    'test':\n      Reduces external interference of IPFS daemon, this\n      is useful when using the daemon in test environments.\n    'default-networking':\n      Restores default network settings.\n      Inverse profile of the test profile.\n    'local-discovery':\n      Sets default values to fields affected by the server\n      profile, enables discovery in local networks.\n\nSUBCOMMANDS\n  ipfs config profile apply <profile> - Apply profile to config.\n\n  For more information about each command, use:\n  'ipfs config profile <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-config-profile-apply"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-config-profile-apply"}},[e._v("#")]),e._v(" ipfs config profile apply")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs config profile apply <profile> - Apply profile to config.\n\nSYNOPSIS\n  ipfs config profile apply [--dry-run] [--] <profile>\n\nARGUMENTS\n\n  <profile> - The profile to apply to the config.\n\nOPTIONS\n\n  --dry-run  bool - print difference between the current config and the config\n                    that would be generated.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-config-replace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-config-replace"}},[e._v("#")]),e._v(" ipfs config replace")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs config replace <file> - Replace the config with <file>.\n\nSYNOPSIS\n  ipfs config replace [--] <file>\n\nARGUMENTS\n\n  <file> - The file to use as the new config.\n\nDESCRIPTION\n\n  Make sure to back up the config file first if necessary, as this operation\n  can't be undone.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-config-show"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-config-show"}},[e._v("#")]),e._v(" ipfs config show")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs config show - Output config file contents.\n\nSYNOPSIS\n  ipfs config show\n\nDESCRIPTION\n\n  NOTE: For security reasons, this command will omit your private key. If you would like to make a full backup of your config (private key included), you must copy the config file from your repo.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-daemon"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-daemon"}},[e._v("#")]),e._v(" ipfs daemon")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs daemon - Run a network-connected IPFS node.\n\nSYNOPSIS\n  ipfs daemon [--init] [--init-config=<init-config>]\n              [--init-profile=<init-profile>] [--routing=<routing>] [--mount]\n              [--writable] [--mount-ipfs=<mount-ipfs>]\n              [--mount-ipns=<mount-ipns>] [--unrestricted-api]\n              [--disable-transport-encryption] [--enable-gc]\n              [--manage-fdlimit=false] [--migrate] [--enable-pubsub-experiment]\n              [--enable-namesys-pubsub] [--enable-mplex-experiment=false]\n\nOPTIONS\n\n  --init                          bool   - Initialize ipfs with default\n                                           settings if not already initialized.\n  --init-config                   string - Path to existing configuration file\n                                           to be loaded during --init.\n  --init-profile                  string - Configuration profiles to apply for\n                                           --init. See ipfs init --help for\n                                           more.\n  --routing                       string - Overrides the routing option.\n                                           Default: default.\n  --mount                         bool   - Mounts IPFS to the filesystem.\n  --writable                      bool   - Enable writing objects (with POST,\n                                           PUT and DELETE).\n  --mount-ipfs                    string - Path to the mountpoint for IPFS (if\n                                           using --mount). Defaults to config\n                                           setting.\n  --mount-ipns                    string - Path to the mountpoint for IPNS (if\n                                           using --mount). Defaults to config\n                                           setting.\n  --unrestricted-api              bool   - Allow API access to unlisted hashes.\n  --disable-transport-encryption  bool   - Disable transport encryption (for\n                                           debugging protocols).\n  --enable-gc                     bool   - Enable automatic periodic repo\n                                           garbage collection.\n  --manage-fdlimit                bool   - Check and raise file descriptor\n                                           limits if needed. Default: true.\n  --migrate                       bool   - If true, assume yes at the migrate\n                                           prompt. If false, assume no.\n  --enable-pubsub-experiment      bool   - Instantiate the ipfs daemon with the\n                                           experimental pubsub feature enabled.\n  --enable-namesys-pubsub         bool   - Enable IPNS record distribution\n                                           through pubsub; enables pubsub.\n  --enable-mplex-experiment       bool   - Add the experimental \'go-multiplex\'\n                                           stream muxer to libp2p on\n                                           construction. Default: true.\n\nDESCRIPTION\n\n  The daemon will start listening on ports on the network, which are\n  documented in (and can be modified through) \'ipfs config Addresses\'.\n  For example, to change the \'Gateway\' port:\n  \n    ipfs config Addresses.Gateway /ip4/127.0.0.1/tcp/8082\n  \n  The API address can be changed the same way:\n  \n    ipfs config Addresses.API /ip4/127.0.0.1/tcp/5002\n  \n  Make sure to restart the daemon after changing addresses.\n  \n  By default, the gateway is only accessible locally. To expose it to\n  other computers in the network, use 0.0.0.0 as the ip address:\n  \n    ipfs config Addresses.Gateway /ip4/0.0.0.0/tcp/8080\n  \n  Be careful if you expose the API. It is a security risk, as anyone could\n  control your node remotely. If you need to control the node remotely,\n  make sure to protect the port as you would other services or database\n  (firewall, authenticated proxy, etc).\n  \n  HTTP Headers\n  \n  ipfs supports passing arbitrary headers to the API and Gateway. You can\n  do this by setting headers on the API.HTTPHeaders and Gateway.HTTPHeaders\n  keys:\n  \n    ipfs config --json API.HTTPHeaders.X-Special-Header "[\\"so special :)\\"]"\n    ipfs config --json Gateway.HTTPHeaders.X-Special-Header "[\\"so special :)\\"]"\n  \n  Note that the value of the keys is an _array_ of strings. This is because\n  headers can have more than one value, and it is convenient to pass through\n  to other libraries.\n  \n  CORS Headers (for API)\n  \n  You can setup CORS headers the same way:\n  \n    ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin "[\\"example.com\\"]"\n    ipfs config --json API.HTTPHeaders.Access-Control-Allow-Methods "[\\"PUT\\", \\"GET\\", \\"POST\\"]"\n    ipfs config --json API.HTTPHeaders.Access-Control-Allow-Credentials "[\\"true\\"]"\n  \n  Shutdown\n  \n  To shut down the daemon, send a SIGINT signal to it (e.g. by pressing \'Ctrl-C\')\n  or send a SIGTERM signal to it (e.g. with \'kill\'). It may take a while for the\n  daemon to shutdown gracefully, but it can be killed forcibly by sending a\n  second signal.\n  \n  IPFS_PATH environment variable\n  \n  ipfs uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n    export IPFS_PATH=/path/to/ipfsrepo\n  \n  Routing\n  \n  IPFS by default will use a DHT for content routing. There is a highly\n  experimental alternative that operates the DHT in a \'client only\' mode that\n  can be enabled by running the daemon as:\n  \n    ipfs daemon --routing=dhtclient\n  \n  This will later be transitioned into a config option once it gets out of the\n  \'experimental\' stage.\n  \n  DEPRECATION NOTICE\n  \n  Previously, ipfs used an environment variable as seen below:\n  \n    export API_ORIGIN="http://localhost:8888/"\n  \n  This is deprecated. It is still honored in this version, but will be removed\n  in a future version, along with this notice. Please move to setting the HTTP\n  Headers.\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-dag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dag"}},[e._v("#")]),e._v(" ipfs dag")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dag - Interact with ipld dag objects.\n\nSYNOPSIS\n  ipfs dag\n\nDESCRIPTION\n\n  'ipfs dag' is used for creating and manipulating dag objects/hierarchies.\n  \n  This subcommand is currently an experimental feature, but it is intended\n  to deprecate and replace the existing 'ipfs object' command moving forward.\n  \t\t\n\nSUBCOMMANDS\n  ipfs dag export <root>        - Streams the selected DAG as a .car stream on\n                                  stdout.\n  ipfs dag get <ref>            - Get a dag node from ipfs.\n  ipfs dag import <path>...     - Import the contents of .car files\n  ipfs dag put <object data>... - Add a dag node to ipfs.\n  ipfs dag resolve <ref>        - Resolve ipld block\n\n  For more information about each command, use:\n  'ipfs dag <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-dag-export"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dag-export"}},[e._v("#")]),e._v(" ipfs dag export")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dag export <root> - Streams the selected DAG as a .car stream on stdout.\n\nSYNOPSIS\n  ipfs dag export [--progress | -p] [--] <root>\n\nARGUMENTS\n\n  <root> - CID of a root to recursively export\n\nOPTIONS\n\n  -p, --progress  bool - Display progress on CLI. Defaults to true when STDERR\n                         is a TTY.\n\nDESCRIPTION\n\n  'ipfs dag export' fetches a dag and streams it out as a well-formed .car file.\n  Note that at present only single root selections / .car files are supported.\n  The output of blocks happens in strict DAG-traversal, first-seen, order.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dag-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dag-get"}},[e._v("#")]),e._v(" ipfs dag get")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dag get <ref> - Get a dag node from ipfs.\n\nSYNOPSIS\n  ipfs dag get [--] <ref>\n\nARGUMENTS\n\n  <ref> - The object to get\n\nDESCRIPTION\n\n  'ipfs dag get' fetches a dag node from ipfs and prints it out in the specified\n  format.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dag-import"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dag-import"}},[e._v("#")]),e._v(" ipfs dag import")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dag import <path>... - Import the contents of .car files\n\nSYNOPSIS\n  ipfs dag import [--silent] [--pin-roots=false] [--] <path>...\n\nARGUMENTS\n\n  <path>... - The path of a .car file.\n\nOPTIONS\n\n  --silent     bool - No output.\n  --pin-roots  bool - Pin optional roots listed in the .car headers after\n                      importing. Default: true.\n\nDESCRIPTION\n\n  'ipfs dag import' imports all blocks present in supplied .car\n  ( Content Address aRchive ) files, recursively pinning any roots\n  specified in the CAR file headers, unless --pin-roots is set to false.\n  \n  Note:\n    This command will import all blocks in the CAR file, not just those\n    reachable from the specified roots. However, these other blocks will\n    not be pinned and may be garbage collected later.\n  \n    The pinning of the roots happens after all car files are processed,\n    permitting import of DAGs spanning multiple files.\n  \n    Pinning takes place in offline-mode exclusively, one root at a time.\n    If the combination of blocks from the imported CAR files and what is\n    currently present in the blockstore does not represent a complete DAG,\n    pinning of that individual root will fail.\n  \n  Maximum supported CAR version: 1\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dag-put"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dag-put"}},[e._v("#")]),e._v(" ipfs dag put")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dag put <object data>... - Add a dag node to ipfs.\n\nSYNOPSIS\n  ipfs dag put [--format=<format> | -f] [--input-enc=<input-enc>] [--pin]\n               [--hash=<hash>] [--] <object data>...\n\nARGUMENTS\n\n  <object data>... - The object to put\n\nOPTIONS\n\n  -f, --format  string - Format that the object will be added as. Default: cbor.\n  --input-enc   string - Format that the input object will be. Default: json.\n  --pin         bool   - Pin this object when adding.\n  --hash        string - Hash function to use. Default: .\n\nDESCRIPTION\n\n  'ipfs dag put' accepts input from a file or stdin and parses it\n  into an object of the specified format.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dag-resolve"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dag-resolve"}},[e._v("#")]),e._v(" ipfs dag resolve")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dag resolve <ref> - Resolve ipld block\n\nSYNOPSIS\n  ipfs dag resolve [--] <ref>\n\nARGUMENTS\n\n  <ref> - The path to resolve\n\nDESCRIPTION\n\n  'ipfs dag resolve' fetches a dag node from ipfs, prints its address and remaining path.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht"}},[e._v("#")]),e._v(" ipfs dht")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht - Issue commands directly through the DHT.\n\nSYNOPSIS\n  ipfs dht\n\nSUBCOMMANDS\n  ipfs dht findpeer <peerID>...   - Find the multiaddresses associated with a\n                                    Peer ID.\n  ipfs dht findprovs <key>...     - Find peers that can provide a specific\n                                    value, given a key.\n  ipfs dht get <key>...           - Given a key, query the routing system for\n                                    its best value.\n  ipfs dht provide <key>...       - Announce to the network that you are\n                                    providing given values.\n  ipfs dht put <key> <value-file> - Write a key/value pair to the routing\n                                    system.\n  ipfs dht query <peerID>...      - Find the closest Peer IDs to a given Peer\n                                    ID by querying the DHT.\n\n  For more information about each command, use:\n  'ipfs dht <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht-findpeer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht-findpeer"}},[e._v("#")]),e._v(" ipfs dht findpeer")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht findpeer <peerID>... - Find the multiaddresses associated with a\n                                  Peer ID.\n\nSYNOPSIS\n  ipfs dht findpeer [--verbose | -v] [--] <peerID>...\n\nARGUMENTS\n\n  <peerID>... - The ID of the peer to search for.\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Outputs a list of newline-delimited multiaddresses.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht-findprovs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht-findprovs"}},[e._v("#")]),e._v(" ipfs dht findprovs")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht findprovs <key>... - Find peers that can provide a specific value,\n                                given a key.\n\nSYNOPSIS\n  ipfs dht findprovs [--verbose | -v] [--num-providers=<num-providers> | -n]\n                     [--] <key>...\n\nARGUMENTS\n\n  <key>... - The key to find providers for.\n\nOPTIONS\n\n  -v, --verbose        bool - Print extra information.\n  -n, --num-providers  int  - The number of providers to find. Default: 20.\n\nDESCRIPTION\n\n  Outputs a list of newline-delimited provider Peer IDs.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht-get"}},[e._v("#")]),e._v(" ipfs dht get")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht get <key>... - Given a key, query the routing system for its best\n                          value.\n\nSYNOPSIS\n  ipfs dht get [--verbose | -v] [--] <key>...\n\nARGUMENTS\n\n  <key>... - The key to find a value for.\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Outputs the best value for the given key.\n  \n  There may be several different values for a given key stored in the routing\n  system; in this context 'best' means the record that is most desirable. There is\n  no one metric for 'best': it depends entirely on the key type. For IPNS, 'best'\n  is the record that is both valid and has the highest sequence number (freshest).\n  Different key types can specify other 'best' rules.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht-provide"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht-provide"}},[e._v("#")]),e._v(" ipfs dht provide")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht provide <key>... - Announce to the network that you are providing\n                              given values.\n\nSYNOPSIS\n  ipfs dht provide [--verbose | -v] [--recursive | -r] [--] <key>...\n\nARGUMENTS\n\n  <key>... - The key[s] to send provide records for.\n\nOPTIONS\n\n  -v, --verbose    bool - Print extra information.\n  -r, --recursive  bool - Recursively provide entire graph.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht-put"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht-put"}},[e._v("#")]),e._v(" ipfs dht put")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht put <key> <value-file> - Write a key/value pair to the routing\n                                    system.\n\nSYNOPSIS\n  ipfs dht put [--verbose | -v] [--] <key> <value-file>\n\nARGUMENTS\n\n  <key>        - The key to store the value at.\n  <value-file> - A path to a file containing the value to store.\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Given a key of the form /foo/bar and a valid value for that key, this will write\n  that value to the routing system with that key.\n  \n  Keys have two parts: a keytype (foo) and the key name (bar). IPNS uses the\n  /ipns keytype, and expects the key name to be a Peer ID. IPNS entries are\n  specifically formatted (protocol buffer).\n  \n  You may only use keytypes that are supported in your ipfs binary: currently\n  this is only /ipns. Unless you have a relatively deep understanding of the\n  go-ipfs routing internals, you likely want to be using 'ipfs name publish' instead\n  of this.\n  \n  The value must be a valid value for the given key type. For example, if the key\n  is /ipns/QmFoo, the value must be IPNS record (protobuf) signed with the key\n  identified by QmFoo.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dht-query"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dht-query"}},[e._v("#")]),e._v(" ipfs dht query")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dht query <peerID>... - Find the closest Peer IDs to a given Peer ID by\n                               querying the DHT.\n\nSYNOPSIS\n  ipfs dht query [--verbose | -v] [--] <peerID>...\n\nARGUMENTS\n\n  <peerID>... - The peerID to run the query against.\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Outputs a list of newline-delimited Peer IDs.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-diag"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-diag"}},[e._v("#")]),e._v(" ipfs diag")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs diag - Generate diagnostic reports.\n\nSYNOPSIS\n  ipfs diag\n\nSUBCOMMANDS\n  ipfs diag cmds - List commands run on this IPFS node.\n  ipfs diag sys  - Print system diagnostic information.\n\n  For more information about each command, use:\n  'ipfs diag <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-diag-cmds"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-diag-cmds"}},[e._v("#")]),e._v(" ipfs diag cmds")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs diag cmds - List commands run on this IPFS node.\n\nSYNOPSIS\n  ipfs diag cmds [--verbose | -v]\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  Lists running and recently run commands.\n\nSUBCOMMANDS\n  ipfs diag cmds clear           - Clear inactive requests from the log.\n  ipfs diag cmds set-time <time> - Set how long to keep inactive requests in\n                                   the log.\n\n  For more information about each command, use:\n  'ipfs diag cmds <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-diag-cmds-clear"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-diag-cmds-clear"}},[e._v("#")]),e._v(" ipfs diag cmds clear")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs diag cmds clear - Clear inactive requests from the log.\n\nSYNOPSIS\n  ipfs diag cmds clear\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-diag-cmds-set-time"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-diag-cmds-set-time"}},[e._v("#")]),e._v(" ipfs diag cmds set-time")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs diag cmds set-time <time> - Set how long to keep inactive requests in\n                                   the log.\n\nSYNOPSIS\n  ipfs diag cmds set-time [--] <time>\n\nARGUMENTS\n\n  <time> - Time to keep inactive requests in log.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-diag-sys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-diag-sys"}},[e._v("#")]),e._v(" ipfs diag sys")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs diag sys - Print system diagnostic information.\n\nSYNOPSIS\n  ipfs diag sys\n\nDESCRIPTION\n\n  Prints out information about your computer to aid in easier debugging.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-dns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-dns"}},[e._v("#")]),e._v(" ipfs dns")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs dns <domain-name> - Resolve DNS links.\n\nSYNOPSIS\n  ipfs dns [--recursive=false] [--] <domain-name>\n\nARGUMENTS\n\n  <domain-name> - The domain-name name to resolve.\n\nOPTIONS\n\n  -r, --recursive  bool - Resolve until the result is not a DNS link. Default:\n                          true.\n\nDESCRIPTION\n\n  Multihashes are hard to remember, but domain names are usually easy to\n  remember.  To create memorable aliases for multihashes, DNS TXT\n  records can point to other DNS links, IPFS objects, IPNS keys, etc.\n  This command resolves those links to the referenced object.\n  \n  Note: This command can only recursively resolve DNS links,\n  it will fail to recursively resolve through IPNS keys etc.\n  For general-purpose recursive resolution, use ipfs name resolve -r.\n  \n  For example, with this DNS TXT record:\n  \n  \t> dig +short TXT _dnslink.ipfs.io\n  \tdnslink=/ipfs/QmRzTuh2Lpuz7Gr39stNr6mTFdqAghsZec1JoUnfySUzcy\n  \n  The resolver will give:\n  \n  \t> ipfs dns ipfs.io\n  \t/ipfs/QmRzTuh2Lpuz7Gr39stNr6mTFdqAghsZec1JoUnfySUzcy\n  \n  The resolver can recursively resolve:\n  \n  \t> dig +short TXT recursive.ipfs.io\n  \tdnslink=/ipns/ipfs.io\n  \t> ipfs dns -r recursive.ipfs.io\n  \t/ipfs/QmRzTuh2Lpuz7Gr39stNr6mTFdqAghsZec1JoUnfySUzcy\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-file"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-file"}},[e._v("#")]),e._v(" ipfs file")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs file - Interact with IPFS objects representing Unix filesystems.\n\nSYNOPSIS\n  ipfs file\n\nDESCRIPTION\n\n  'ipfs file' provides a familiar interface to file systems represented\n  by IPFS objects, which hides ipfs implementation details like layout\n  objects (e.g. fanout and chunking).\n\nSUBCOMMANDS\n  ipfs file ls <ipfs-path>... - List directory contents for Unix filesystem\n                                objects.\n\n  For more information about each command, use:\n  'ipfs file <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-file-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-file-ls"}},[e._v("#")]),e._v(" ipfs file ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs file ls <ipfs-path>... - List directory contents for Unix filesystem\n                                objects.\n\nSYNOPSIS\n  ipfs file ls [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - The path to the IPFS object(s) to list links from.\n\nDESCRIPTION\n\n  Displays the contents of an IPFS or IPNS object(s) at the given path.\n  \n  The JSON output contains size information. For files, the child size\n  is the total size of the file contents. For directories, the child\n  size is the IPFS link size.\n  \n  The path can be a prefixless ref; in this case, we assume it to be an\n  /ipfs ref and not /ipns.\n  \n  Example:\n  \n      > ipfs file ls QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ\n      cat.jpg\n      > ipfs file ls /ipfs/QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ\n      cat.jpg\n  \n  This functionality is deprecated, and will be removed in future versions. If\n  possible, please use 'ipfs ls' instead.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files"}},[e._v("#")]),e._v(" ipfs files")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs files - Interact with unixfs files.\n\nSYNOPSIS\n  ipfs files [--flush=false]\n\nOPTIONS\n\n  -f, --flush  bool - Flush target and ancestors after write. Default: true.\n\nDESCRIPTION\n\n  Files is an API for manipulating IPFS objects as if they were a Unix\n  filesystem.\n  \n  The files facility interacts with MFS (Mutable File System). MFS acts as a\n  single, dynamic filesystem mount. MFS has a root CID that is transparently\n  updated when a change happens (and can be checked with "ipfs files stat /").\n  \n  All files and folders within MFS are respected and will not be cleaned up\n  during garbage collections. MFS is independent from the list of pinned items\n  ("ipfs pin ls"). Calls to "ipfs pin add" and "ipfs pin rm" will add and remove\n  pins independently of MFS. If MFS content that was\n  additionally pinned is removed by calling "ipfs files rm", it will still\n  remain pinned.\n  \n  Content added with "ipfs add" (which by default also becomes pinned), is not\n  added to MFS. Any content can be put into MFS with the command "ipfs files cp\n  /ipfs/<cid> /some/path/".\n  \n  \n  NOTE:\n  Most of the subcommands of \'ipfs files\' accept the \'--flush\' flag. It defaults\n  to true. Use caution when setting this flag to false. It will improve\n  performance for large numbers of file operations, but it does so at the cost\n  of consistency guarantees. If the daemon is unexpectedly killed before running\n  \'ipfs files flush\' on the files in question, then data may be lost. This also\n  applies to run \'ipfs repo gc\' concurrently with \'--flush=false\'\n  operations.\n\nSUBCOMMANDS\n  ipfs files chcid [<path>]      - Change the cid version or hash function of\n                                   the root node of a given path.\n  ipfs files cp <source> <dest>  - Copy any IPFS files and directories into MFS\n                                   (or copy within MFS).\n  ipfs files flush [<path>]      - Flush a given path\'s data to disk.\n  ipfs files ls [<path>]         - List directories in the local mutable\n                                   namespace.\n  ipfs files mkdir <path>        - Make directories.\n  ipfs files mv <source> <dest>  - Move files.\n  ipfs files read <path>         - Read a file in a given MFS.\n  ipfs files rm <path>...        - Remove a file.\n  ipfs files stat <path>         - Display file status.\n  ipfs files write <path> <data> - Write to a mutable file in a given\n                                   filesystem.\n\n  For more information about each command, use:\n  \'ipfs files <subcmd> --help\'\n\n')])])]),s("h2",{attrs:{id:"ipfs-files-chcid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-chcid"}},[e._v("#")]),e._v(" ipfs files chcid")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files chcid [<path>] - Change the cid version or hash function of the\n                              root node of a given path.\n\nSYNOPSIS\n  ipfs files chcid [--cid-version=<cid-version> | --cid-ver] [--hash=<hash>]\n                   [--] [<path>]\n\nARGUMENTS\n\n  [<path>] - Path to change. Default: '/'.\n\nOPTIONS\n\n  --cid-ver, --cid-version  int    - Cid version to use. (experimental).\n  --hash                    string - Hash function to use. Will set Cid version\n                                     to 1 if used. (experimental).\n\nDESCRIPTION\n\n  Change the cid version or hash function of the root node of a given path.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-cp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-cp"}},[e._v("#")]),e._v(" ipfs files cp")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs files cp <source> <dest> - Copy any IPFS files and directories into MFS\n                                  (or copy within MFS).\n\nSYNOPSIS\n  ipfs files cp [--] <source> <dest>\n\nARGUMENTS\n\n  <source> - Source IPFS or MFS path to copy.\n  <dest>   - Destination within MFS.\n\nDESCRIPTION\n\n  "ipfs files cp" can be used to copy any IPFS file or directory (usually in the\n  form /ipfs/<CID>, but also any resolvable path), into the Mutable File System\n  (MFS).\n  \n  It can also be used to copy files within MFS, but in the case when an\n  IPFS-path matches an existing MFS path, the IPFS path wins.\n  \n  In order to add content to MFS from disk, you can use "ipfs add" to obtain the\n  IPFS Content Identifier and then "ipfs files cp" to copy it into MFS:\n  \n  $ ipfs add --quieter --pin=false <your file>\n  # ...\n  # ... outputs the root CID at the end\n  $ ipfs cp /ipfs/<CID> /your/desired/mfs/path\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-files-flush"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-flush"}},[e._v("#")]),e._v(" ipfs files flush")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files flush [<path>] - Flush a given path's data to disk.\n\nSYNOPSIS\n  ipfs files flush [--] [<path>]\n\nARGUMENTS\n\n  [<path>] - Path to flush. Default: '/'.\n\nDESCRIPTION\n\n  Flush a given path to the disk. This is only useful when other commands\n  are run with the '--flush=false'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-ls"}},[e._v("#")]),e._v(" ipfs files ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files ls [<path>] - List directories in the local mutable namespace.\n\nSYNOPSIS\n  ipfs files ls [--long | -l] [-U] [--] [<path>]\n\nARGUMENTS\n\n  [<path>] - Path to show listing for. Defaults to '/'.\n\nOPTIONS\n\n  -l, --long  bool - Use long listing format.\n  -U          bool - Do not sort; list entries in directory order.\n\nDESCRIPTION\n\n  List directories in the local mutable namespace.\n  \n  Examples:\n  \n      $ ipfs files ls /welcome/docs/\n      about\n      contact\n      help\n      quick-start\n      readme\n      security-notes\n  \n      $ ipfs files ls /myfiles/a/b/c/d\n      foo\n      bar\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-mkdir"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-mkdir"}},[e._v("#")]),e._v(" ipfs files mkdir")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files mkdir <path> - Make directories.\n\nSYNOPSIS\n  ipfs files mkdir [--parents | -p] [--cid-version=<cid-version> | --cid-ver]\n                   [--hash=<hash>] [--] <path>\n\nARGUMENTS\n\n  <path> - Path to dir to make.\n\nOPTIONS\n\n  -p, --parents             bool   - No error if existing, make parent\n                                     directories as needed.\n  --cid-ver, --cid-version  int    - Cid version to use. (experimental).\n  --hash                    string - Hash function to use. Will set Cid version\n                                     to 1 if used. (experimental).\n\nDESCRIPTION\n\n  Create the directory if it does not already exist.\n  \n  The directory will have the same CID version and hash function of the\n  parent directory unless the --cid-version and --hash options are used.\n  \n  NOTE: All paths must be absolute.\n  \n  Examples:\n  \n      $ ipfs files mkdir /test/newdir\n      $ ipfs files mkdir -p /test/does/not/exist/yet\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-mv"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-mv"}},[e._v("#")]),e._v(" ipfs files mv")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files mv <source> <dest> - Move files.\n\nSYNOPSIS\n  ipfs files mv [--] <source> <dest>\n\nARGUMENTS\n\n  <source> - Source file to move.\n  <dest>   - Destination path for file to be moved to.\n\nDESCRIPTION\n\n  Move files around. Just like the traditional Unix mv.\n  \n  Example:\n  \n      $ ipfs files mv /myfs/a/b/c /myfs/foo/newc\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-read"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-read"}},[e._v("#")]),e._v(" ipfs files read")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files read <path> - Read a file in a given MFS.\n\nSYNOPSIS\n  ipfs files read [--offset=<offset> | -o] [--count=<count> | -n] [--] <path>\n\nARGUMENTS\n\n  <path> - Path to file to be read.\n\nOPTIONS\n\n  -o, --offset  int64 - Byte offset to begin reading from.\n  -n, --count   int64 - Maximum number of bytes to read.\n\nDESCRIPTION\n\n  Read a specified number of bytes from a file at a given offset. By default,\n  it will read the entire file similar to the Unix cat.\n  \n  Examples:\n  \n      $ ipfs files read /test/hello\n      hello\n          \n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-rm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-rm"}},[e._v("#")]),e._v(" ipfs files rm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files rm <path>... - Remove a file.\n\nSYNOPSIS\n  ipfs files rm [--recursive | -r] [--force] [--] <path>...\n\nARGUMENTS\n\n  <path>... - File to remove.\n\nOPTIONS\n\n  -r, --recursive  bool - Recursively remove directories.\n  --force          bool - Forcibly remove target at path; implies -r for\n                          directories.\n\nDESCRIPTION\n\n  Remove files or directories.\n  \n      $ ipfs files rm /foo\n      $ ipfs files ls /bar\n      cat\n      dog\n      fish\n      $ ipfs files rm -r /bar\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-stat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-stat"}},[e._v("#")]),e._v(" ipfs files stat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files stat <path> - Display file status.\n\nSYNOPSIS\n  ipfs files stat [--format=<format>] [--hash] [--size] [--with-local] [--]\n                  <path>\n\nARGUMENTS\n\n  <path> - Path to node to stat.\n\nOPTIONS\n\n  --format      string - Print statistics in given format. Allowed tokens:\n                         <hash> <size> <cumulsize> <type> <childs>. Conflicts\n                         with other format options. Default: <hash>\n  Size:\n                         <size>\n  CumulativeSize: <cumulsize>\n  ChildBlocks:\n                         <childs>\n  Type: <type>.\n  --hash        bool   - Print only hash. Implies '--format=<hash>'. Conflicts\n                         with other format options.\n  --size        bool   - Print only size. Implies '--format=<cumulsize>'.\n                         Conflicts with other format options.\n  --with-local  bool   - Compute the amount of the dag that is local, and if\n                         possible the total size.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-files-write"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-files-write"}},[e._v("#")]),e._v(" ipfs files write")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs files write <path> <data> - Write to a mutable file in a given\n                                   filesystem.\n\nSYNOPSIS\n  ipfs files write [--offset=<offset> | -o] [--create | -e] [--parents | -p]\n                   [--truncate | -t] [--count=<count> | -n] [--raw-leaves]\n                   [--cid-version=<cid-version> | --cid-ver] [--hash=<hash>]\n                   [--] <path> <data>\n\nARGUMENTS\n\n  <path> - Path to write to.\n  <data> - Data to write.\n\nOPTIONS\n\n  -o, --offset              int64  - Byte offset to begin writing at.\n  -e, --create              bool   - Create the file if it does not exist.\n  -p, --parents             bool   - Make parent directories as needed.\n  -t, --truncate            bool   - Truncate the file to size zero before\n                                     writing.\n  -n, --count               int64  - Maximum number of bytes to read.\n  --raw-leaves              bool   - Use raw blocks for newly created leaf\n                                     nodes. (experimental).\n  --cid-ver, --cid-version  int    - Cid version to use. (experimental).\n  --hash                    string - Hash function to use. Will set Cid version\n                                     to 1 if used. (experimental).\n\nDESCRIPTION\n\n  Write data to a file in a given filesystem. This command allows you to specify\n  a beginning offset to write to. The entire length of the input will be\n  written.\n  \n  If the '--create' option is specified, the file will be created if it does not\n  exist. Nonexistent intermediate directories will not be created unless the\n  '--parents' option is specified.\n  \n  Newly created files will have the same CID version and hash function of the\n  parent directory unless the '--cid-version' and '--hash' options are used.\n  \n  Newly created leaves will be in the legacy format (Protobuf) if the\n  CID version is 0, or raw if the CID version is non-zero.  Use of the\n  '--raw-leaves' option will override this behavior.\n  \n  If the '--flush' option is set to false, changes will not be propagated to the\n  merkledag root. This can make operations much faster when doing a large number\n  of writes to a deeper directory structure.\n  \n  EXAMPLE:\n  \n      echo \"hello world\" | ipfs files write --create --parents /myfs/a/b/file\n      echo \"hello world\" | ipfs files write --truncate /myfs/a/b/file\n  \n  WARNING:\n  \n  Usage of the '--flush=false' option does not guarantee data durability until\n  the tree has been flushed. This can be accomplished by running 'ipfs files\n  stat' on the file or any of its ancestors.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-filestore"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-filestore"}},[e._v("#")]),e._v(" ipfs filestore")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs filestore - Interact with filestore objects.\n\nSYNOPSIS\n  ipfs filestore\n\nSUBCOMMANDS\n  ipfs filestore dups              - List blocks that are both in the filestore\n                                     and standard block storage.\n  ipfs filestore ls [<obj>]...     - List objects in filestore.\n  ipfs filestore verify [<obj>]... - Verify objects in filestore.\n\n  For more information about each command, use:\n  'ipfs filestore <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-filestore-dups"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-filestore-dups"}},[e._v("#")]),e._v(" ipfs filestore dups")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs filestore dups - List blocks that are both in the filestore and standard\n                        block storage.\n\nSYNOPSIS\n  ipfs filestore dups\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-filestore-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-filestore-ls"}},[e._v("#")]),e._v(" ipfs filestore ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs filestore ls [<obj>]... - List objects in filestore.\n\nSYNOPSIS\n  ipfs filestore ls [--file-order] [--] [<obj>...]\n\nARGUMENTS\n\n  [<obj>]... - Cid of objects to list.\n\nOPTIONS\n\n  --file-order  bool - sort the results based on the path of the backing file.\n\nDESCRIPTION\n\n  List objects in the filestore.\n  \n  If one or more <obj> is specified only list those specific objects,\n  otherwise list all objects.\n  \n  The output is:\n  \n  <hash> <size> <path> <offset>\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-filestore-verify"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-filestore-verify"}},[e._v("#")]),e._v(" ipfs filestore verify")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs filestore verify [<obj>]... - Verify objects in filestore.\n\nSYNOPSIS\n  ipfs filestore verify [--file-order] [--] [<obj>...]\n\nARGUMENTS\n\n  [<obj>]... - Cid of objects to verify.\n\nOPTIONS\n\n  --file-order  bool - verify the objects based on the order of the backing\n                       file.\n\nDESCRIPTION\n\n  Verify objects in the filestore.\n  \n  If one or more <obj> is specified only verify those specific objects,\n  otherwise verify all objects.\n  \n  The output is:\n  \n  <status> <hash> <size> <path> <offset>\n  \n  Where <status> is one of:\n  ok:       the block can be reconstructed\n  changed:  the contents of the backing file have changed\n  no-file:  the backing file could not be found\n  error:    there was some other problem reading the file\n  missing:  <obj> could not be found in the filestore\n  ERROR:    internal error, most likely due to a corrupt database\n  \n  For ERROR entries the error will also be printed to stderr.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-get"}},[e._v("#")]),e._v(" ipfs get")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs get <ipfs-path> - Download IPFS objects.\n\nSYNOPSIS\n  ipfs get [--output=<output> | -o] [--archive | -a] [--compress | -C]\n           [--compression-level=<compression-level> | -l] [--] <ipfs-path>\n\nARGUMENTS\n\n  <ipfs-path> - The path to the IPFS object(s) to be outputted.\n\nOPTIONS\n\n  -o, --output             string - The path where the output should be stored.\n  -a, --archive            bool   - Output a TAR archive.\n  -C, --compress           bool   - Compress the output with GZIP compression.\n  -l, --compression-level  int    - The level of compression (1-9).\n\nDESCRIPTION\n\n  Stores to disk the data contained an IPFS or IPNS object(s) at the given path.\n  \n  By default, the output will be stored at './<ipfs-path>', but an alternate\n  path can be specified with '--output=<path>' or '-o=<path>'.\n  \n  To output a TAR archive instead of unpacked files, use '--archive' or '-a'.\n  \n  To compress the output with GZIP compression, use '--compress' or '-C'. You\n  may also specify the level of compression by specifying '-l=<1-9>'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-id"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-id"}},[e._v("#")]),e._v(" ipfs id")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs id [<peerid>] - Show ipfs node id info.\n\nSYNOPSIS\n  ipfs id [--format=<format> | -f] [--] [<peerid>]\n\nARGUMENTS\n\n  [<peerid>] - Peer.ID of node to look up.\n\nOPTIONS\n\n  -f, --format  string - Optional output format.\n\nDESCRIPTION\n\n  Prints out information about the specified peer.\n  If no peer is specified, prints out information for local peers.\n  \n  'ipfs id' supports the format option for output with the following keys:\n  <id> : The peers id.\n  <aver>: Agent version.\n  <pver>: Protocol version.\n  <pubkey>: Public key.\n  <addrs>: Addresses (newline delimited).\n  \n  EXAMPLE:\n  \n      ipfs id Qmece2RkXhsKe5CRooNisBTh4SK119KrXXGmoK6V3kb8aH -f=\"<addrs>\\n\"\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-init"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-init"}},[e._v("#")]),e._v(" ipfs init")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs init [<default-config>] - Initializes ipfs config file.\n\nSYNOPSIS\n  ipfs init [--bits=<bits> | -b] [--empty-repo | -e] [--profile=<profile> | -p]\n            [--] [<default-config>]\n\nARGUMENTS\n\n  [<default-config>] - Initialize with the given configuration.\n\nOPTIONS\n\n  -b, --bits        int    - Number of bits to use in the generated RSA private\n                             key. Default: 2048.\n  -e, --empty-repo  bool   - Don't add and pin help files to the local storage.\n  -p, --profile     string - Apply profile settings to config. Multiple\n                             profiles can be separated by ','.\n\nDESCRIPTION\n\n  Initializes ipfs configuration files and generates a new keypair.\n  \n  If you are going to run IPFS in server environment, you may want to\n  initialize it using 'server' profile.\n  \n  For the list of available profiles see 'ipfs config profile --help'\n  \n  ipfs uses a repository in the local file system. By default, the repo is\n  located at ~/.ipfs. To change the repo location, set the $IPFS_PATH\n  environment variable:\n  \n      export IPFS_PATH=/path/to/ipfsrepo\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-key"}},[e._v("#")]),e._v(" ipfs key")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs key - Create and list IPNS name keypairs\n\nSYNOPSIS\n  ipfs key\n\nDESCRIPTION\n\n  'ipfs key gen' generates a new keypair for usage with IPNS and 'ipfs name\n  publish'.\n  \n    > ipfs key gen --type=rsa --size=2048 mykey\n    > ipfs name publish --key=mykey QmSomeHash\n  \n  'ipfs key list' lists the available keys.\n  \n    > ipfs key list\n    self\n    mykey\n  \t\t\n\nSUBCOMMANDS\n  ipfs key gen <name>              - Create a new keypair\n  ipfs key list                    - List all local keypairs\n  ipfs key rename <name> <newName> - Rename a keypair\n  ipfs key rm <name>...            - Remove a keypair\n\n  For more information about each command, use:\n  'ipfs key <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-key-gen"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-key-gen"}},[e._v("#")]),e._v(" ipfs key gen")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs key gen <name> - Create a new keypair\n\nSYNOPSIS\n  ipfs key gen [--type=<type> | -t] [--size=<size> | -s] [--] <name>\n\nARGUMENTS\n\n  <name> - name of key to create\n\nOPTIONS\n\n  -t, --type  string - type of the key to create: rsa, ed25519. Default: rsa.\n  -s, --size  int    - size of the key to generate.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-key-list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-key-list"}},[e._v("#")]),e._v(" ipfs key list")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs key list - List all local keypairs\n\nSYNOPSIS\n  ipfs key list [-l]\n\nOPTIONS\n\n  -l  bool - Show extra information about keys.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-key-rename"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-key-rename"}},[e._v("#")]),e._v(" ipfs key rename")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs key rename <name> <newName> - Rename a keypair\n\nSYNOPSIS\n  ipfs key rename [--force | -f] [--] <name> <newName>\n\nARGUMENTS\n\n  <name>    - name of key to rename\n  <newName> - new name of the key\n\nOPTIONS\n\n  -f, --force  bool - Allow to overwrite an existing key.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-key-rm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-key-rm"}},[e._v("#")]),e._v(" ipfs key rm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs key rm <name>... - Remove a keypair\n\nSYNOPSIS\n  ipfs key rm [-l] [--] <name>...\n\nARGUMENTS\n\n  <name>... - names of keys to remove\n\nOPTIONS\n\n  -l  bool - Show extra information about keys.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-log"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-log"}},[e._v("#")]),e._v(" ipfs log")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs log - Interact with the daemon log output.\n\nSYNOPSIS\n  ipfs log\n\nDESCRIPTION\n\n  'ipfs log' contains utility commands to affect or read the logging\n  output of a running daemon.\n  \n  There are also two environmental variables that direct the logging \n  system (not just for the daemon logs, but all commands):\n      IPFS_LOGGING - sets the level of verbosity of the logging.\n          One of: debug, info, warn, error, dpanic, panic, fatal\n      IPFS_LOGGING_FMT - sets formatting of the log output.\n          One of: color, nocolor\n\nSUBCOMMANDS\n  ipfs log level <subsystem> <level> - Change the logging level.\n  ipfs log ls                        - List the logging subsystems.\n  ipfs log tail                      - Read the event log.\n\n  For more information about each command, use:\n  'ipfs log <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-log-level"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-log-level"}},[e._v("#")]),e._v(" ipfs log level")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs log level <subsystem> <level> - Change the logging level.\n\nSYNOPSIS\n  ipfs log level [--] <subsystem> <level>\n\nARGUMENTS\n\n  <subsystem> - The subsystem logging identifier. Use 'all' for all subsystems.\n  <level>     - The log level, with 'debug' the most verbose and 'fatal' the\n                least verbose.\n  \t\t\tOne of: debug, info, warn, error, dpanic,\n                panic, fatal.\n\nDESCRIPTION\n\n  Change the verbosity of one or all subsystems log output. This does not affect\n  the event log.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-log-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-log-ls"}},[e._v("#")]),e._v(" ipfs log ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs log ls - List the logging subsystems.\n\nSYNOPSIS\n  ipfs log ls\n\nDESCRIPTION\n\n  'ipfs log ls' is a utility command used to list the logging\n  subsystems of a running daemon.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-log-tail"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-log-tail"}},[e._v("#")]),e._v(" ipfs log tail")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs log tail - Read the event log.\n\nSYNOPSIS\n  ipfs log tail\n\nDESCRIPTION\n\n  Outputs event log messages (not other log messages) as they are generated.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-ls"}},[e._v("#")]),e._v(" ipfs ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs ls <ipfs-path>... - List directory contents for Unix filesystem objects.\n\nSYNOPSIS\n  ipfs ls [--headers | -v] [--resolve-type=false] [--size=false] [--stream | -s]\n          [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - The path to the IPFS object(s) to list links from.\n\nOPTIONS\n\n  -v, --headers   bool - Print table headers (Hash, Size, Name).\n  --resolve-type  bool - Resolve linked objects to find out their types.\n                         Default: true.\n  --size          bool - Resolve linked objects to find out their file size.\n                         Default: true.\n  -s, --stream    bool - Enable experimental streaming of directory entries as\n                         they are traversed.\n\nDESCRIPTION\n\n  Displays the contents of an IPFS or IPNS object(s) at the given path, with\n  the following format:\n  \n    <link base58 hash> <link size in bytes> <link name>\n  \n  The JSON output contains type information.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-mount"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-mount"}},[e._v("#")]),e._v(" ipfs mount")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs mount - Mounts IPFS to the filesystem (read-only).\n\nSYNOPSIS\n  ipfs mount [--ipfs-path=<ipfs-path> | -f] [--ipns-path=<ipns-path> | -n]\n\nOPTIONS\n\n  -f, --ipfs-path  string - The path where IPFS should be mounted.\n  -n, --ipns-path  string - The path where IPNS should be mounted.\n\nDESCRIPTION\n\n  Mount IPFS at a read-only mountpoint on the OS. The default, /ipfs and /ipns,\n  are set in the configuration file, but can be overridden by the options.\n  All IPFS objects will be accessible under this directory. Note that the\n  root will not be listable, as it is virtual. Access known paths directly.\n  \n  You may have to create /ipfs and /ipns before using 'ipfs mount':\n  \n  > sudo mkdir /ipfs /ipns\n  > sudo chown $(whoami) /ipfs /ipns\n  > ipfs daemon &\n  > ipfs mount\n  \n  Example:\n  \n  # setup\n  > mkdir foo\n  > echo \"baz\" > foo/bar\n  > ipfs add -r foo\n  added QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR foo/bar\n  added QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC foo\n  > ipfs ls QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC\n  QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR 12 bar\n  > ipfs cat QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR\n  baz\n  \n  # mount\n  > ipfs daemon &\n  > ipfs mount\n  IPFS mounted at: /ipfs\n  IPNS mounted at: /ipns\n  > cd /ipfs/QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC\n  > ls\n  bar\n  > cat bar\n  baz\n  > cat /ipfs/QmSh5e7S6fdcu75LAbXNZAFY2nGyZUJXyLCJDvn2zRkWyC/bar\n  baz\n  > cat /ipfs/QmWLdkp93sNxGRjnFHPaYg8tCQ35NBY3XPn6KiETd3Z4WR\n  baz\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-name"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name"}},[e._v("#")]),e._v(" ipfs name")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs name - Publish and resolve IPNS names.\n\nSYNOPSIS\n  ipfs name\n\nDESCRIPTION\n\n  IPNS is a PKI namespace, where names are the hashes of public keys, and\n  the private key enables publishing new (signed) values. In both publish\n  and resolve, the default name used is the node's own PeerID,\n  which is the hash of its public key.\n  \n  You can use the 'ipfs key' commands to list and generate more names and their\n  respective keys.\n  \n  Examples:\n  \n  Publish an <ipfs-path> with your default name:\n  \n    > ipfs name publish /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Publish an <ipfs-path> with another name, added by an 'ipfs key' command:\n  \n    > ipfs key gen --type=rsa --size=2048 mykey\n    > ipfs name publish --key=mykey /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of your name:\n  \n    > ipfs name resolve\n    /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of another name:\n  \n    > ipfs name resolve QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n    /ipfs/QmSiTko9JZyabH56y2fussEt1A5oDqsFXB3CkvAqraFryz\n  \n  Resolve the value of a dnslink:\n  \n    > ipfs name resolve ipfs.io\n    /ipfs/QmaBvfZooxWkrv7D3r8LS9moNjzD2o525XMZze69hhoxf5\n\nSUBCOMMANDS\n  ipfs name publish <ipfs-path> - Publish IPNS names.\n  ipfs name pubsub              - IPNS pubsub management\n  ipfs name resolve [<name>]    - Resolve IPNS names.\n\n  For more information about each command, use:\n  'ipfs name <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-name-publish"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name-publish"}},[e._v("#")]),e._v(" ipfs name publish")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs name publish <ipfs-path> - Publish IPNS names.\n\nSYNOPSIS\n  ipfs name publish [--resolve=false] [--lifetime=<lifetime> | -t]\n                    [--allow-offline] [--ttl=<ttl>] [--key=<key> | -k]\n                    [--quieter | -Q] [--] <ipfs-path>\n\nARGUMENTS\n\n  <ipfs-path> - ipfs path of the object to be published.\n\nOPTIONS\n\n  --resolve        bool   - Check if the given path can be resolved before\n                            publishing. Default: true.\n  -t, --lifetime   string - Time duration that the record will be valid for.\n                            Default: 24h.\n      This accepts durations such as\n                            "300s", "1.5h" or "2h45m". Valid time units are\n     \n                            "ns", "us" (or "µs"), "ms", "s", "m", "h".\n  --allow-offline  bool   - When offline, save the IPNS record to the the local\n                            datastore without broadcasting to the network\n                            instead of simply failing.\n  --ttl            string - Time duration this record should be cached for.\n                            Uses the same syntax as the lifetime option.\n                            (caution: experimental).\n  -k, --key        string - Name of the key to be used or a valid PeerID, as\n                            listed by \'ipfs key list -l\'. Default: self.\n  -Q, --quieter    bool   - Write only final hash.\n\nDESCRIPTION\n\n  IPNS is a PKI namespace, where names are the hashes of public keys, and\n  the private key enables publishing new (signed) values. In both publish\n  and resolve, the default name used is the node\'s own PeerID,\n  which is the hash of its public key.\n  \n  You can use the \'ipfs key\' commands to list and generate more names and their\n  respective keys.\n  \n  Examples:\n  \n  Publish an <ipfs-path> with your default name:\n  \n    > ipfs name publish /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Publish an <ipfs-path> with another name, added by an \'ipfs key\' command:\n  \n    > ipfs key gen --type=rsa --size=2048 mykey\n    > ipfs name publish --key=mykey /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmSrPmbaUKA3ZodhzPWZnpFgcPMFWF4QsxXbkWfEptTBJd: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Alternatively, publish an <ipfs-path> using a valid PeerID (as listed by \n  \'ipfs key list -l\'):\n  \n   > ipfs name publish --key=QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    Published to QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n: /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-name-pubsub"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name-pubsub"}},[e._v("#")]),e._v(" ipfs name pubsub")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs name pubsub - IPNS pubsub management\n\nSYNOPSIS\n  ipfs name pubsub\n\nDESCRIPTION\n\n  Manage and inspect the state of the IPNS pubsub resolver.\n  \n  Note: this command is experimental and subject to change as the system is refined\n\nSUBCOMMANDS\n  ipfs name pubsub cancel <name> - Cancel a name subscription\n  ipfs name pubsub state         - Query the state of IPNS pubsub\n  ipfs name pubsub subs          - Show current name subscriptions\n\n  For more information about each command, use:\n  'ipfs name pubsub <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-name-pubsub-cancel"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name-pubsub-cancel"}},[e._v("#")]),e._v(" ipfs name pubsub cancel")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs name pubsub cancel <name> - Cancel a name subscription\n\nSYNOPSIS\n  ipfs name pubsub cancel [--] <name>\n\nARGUMENTS\n\n  <name> - Name to cancel the subscription for.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-name-pubsub-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name-pubsub-state"}},[e._v("#")]),e._v(" ipfs name pubsub state")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs name pubsub state - Query the state of IPNS pubsub\n\nSYNOPSIS\n  ipfs name pubsub state\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-name-pubsub-subs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name-pubsub-subs"}},[e._v("#")]),e._v(" ipfs name pubsub subs")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs name pubsub subs - Show current name subscriptions\n\nSYNOPSIS\n  ipfs name pubsub subs\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-name-resolve"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-name-resolve"}},[e._v("#")]),e._v(" ipfs name resolve")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs name resolve [<name>] - Resolve IPNS names.\n\nSYNOPSIS\n  ipfs name resolve [--recursive=false] [--nocache | -n]\n                    [--dht-record-count=<dht-record-count> | --dhtrc]\n                    [--dht-timeout=<dht-timeout> | --dhtt] [--stream | -s] [--]\n                    [<name>]\n\nARGUMENTS\n\n  [<name>] - The IPNS name to resolve. Defaults to your node's peerID.\n\nOPTIONS\n\n  -r, --recursive              bool   - Resolve until the result is not an IPNS\n                                        name. Default: true.\n  -n, --nocache                bool   - Do not use cached entries.\n  --dhtrc, --dht-record-count  uint   - Number of records to request for DHT\n                                        resolution.\n  --dhtt, --dht-timeout        string - Max time to collect values during DHT\n                                        resolution eg \"30s\". Pass 0 for no\n                                        timeout.\n  -s, --stream                 bool   - Stream entries as they are found.\n\nDESCRIPTION\n\n  IPNS is a PKI namespace, where names are the hashes of public keys, and\n  the private key enables publishing new (signed) values. In both publish\n  and resolve, the default name used is the node's own PeerID,\n  which is the hash of its public key.\n  \n  You can use the 'ipfs key' commands to list and generate more names and their\n  respective keys.\n  \n  Examples:\n  \n  Resolve the value of your name:\n  \n    > ipfs name resolve\n    /ipfs/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of another name:\n  \n    > ipfs name resolve QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n    /ipfs/QmSiTko9JZyabH56y2fussEt1A5oDqsFXB3CkvAqraFryz\n  \n  Resolve the value of a dnslink:\n  \n    > ipfs name resolve ipfs.io\n    /ipfs/QmaBvfZooxWkrv7D3r8LS9moNjzD2o525XMZze69hhoxf5\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-object"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object"}},[e._v("#")]),e._v(" ipfs object")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object - Interact with IPFS objects.\n\nSYNOPSIS\n  ipfs object\n\nDESCRIPTION\n\n  'ipfs object' is a plumbing command used to manipulate DAG objects\n  directly.\n\nSUBCOMMANDS\n  ipfs object data <key>           - Output the raw bytes of an IPFS object.\n  ipfs object diff <obj_a> <obj_b> - Display the diff between two ipfs objects.\n  ipfs object get <key>            - Get and serialize the DAG node named by\n                                     <key>.\n  ipfs object links <key>          - Output the links pointed to by the\n                                     specified object.\n  ipfs object new [<template>]     - Create a new object from an ipfs template.\n  ipfs object patch                - Create a new merkledag object based on an\n                                     existing one.\n  ipfs object put <data>           - Store input as a DAG object, print its key.\n  ipfs object stat <key>           - Get stats for the DAG node named by <key>.\n\n  For more information about each command, use:\n  'ipfs object <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-data"}},[e._v("#")]),e._v(" ipfs object data")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object data <key> - Output the raw bytes of an IPFS object.\n\nSYNOPSIS\n  ipfs object data [--] <key>\n\nARGUMENTS\n\n  <key> - Key of the object to retrieve, in base58-encoded multihash format.\n\nDESCRIPTION\n\n  'ipfs object data' is a plumbing command for retrieving the raw bytes stored\n  in a DAG node. It outputs to stdout, and <key> is a base58 encoded multihash.\n  \n  Note that the \"--encoding\" option does not affect the output, since the output\n  is the raw data of the object.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-diff"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-diff"}},[e._v("#")]),e._v(" ipfs object diff")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs object diff <obj_a> <obj_b> - Display the diff between two ipfs objects.\n\nSYNOPSIS\n  ipfs object diff [--verbose | -v] [--] <obj_a> <obj_b>\n\nARGUMENTS\n\n  <obj_a> - Object to diff against.\n  <obj_b> - Object to diff.\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n\nDESCRIPTION\n\n  \'ipfs object diff\' is a command used to show the differences between\n  two IPFS objects.\n  \n  Example:\n  \n     > ls foo\n     bar baz/ giraffe\n     > ipfs add -r foo\n     ...\n     Added QmegHcnrPgMwC7tBiMxChD54fgQMBUecNw9nE9UUU4x1bz foo\n     > OBJ_A=QmegHcnrPgMwC7tBiMxChD54fgQMBUecNw9nE9UUU4x1bz\n     > echo "different content" > foo/bar\n     > ipfs add -r foo\n     ...\n     Added QmcmRptkSPWhptCttgHg27QNDmnV33wAJyUkCnAvqD3eCD foo\n     > OBJ_B=QmcmRptkSPWhptCttgHg27QNDmnV33wAJyUkCnAvqD3eCD\n     > ipfs object diff -v $OBJ_A $OBJ_B\n     Changed "bar" from QmNgd5cz2jNftnAHBhcRUGdtiaMzb5Rhjqd4etondHHST8 to QmRfFVsjSXkhFxrfWnLpMae2M4GBVsry6VAuYYcji5MiZb.\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-object-get"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-get"}},[e._v("#")]),e._v(" ipfs object get")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs object get <key> - Get and serialize the DAG node named by <key>.\n\nSYNOPSIS\n  ipfs object get [--data-encoding=<data-encoding>] [--] <key>\n\nARGUMENTS\n\n  <key> - Key of the object to retrieve, in base58-encoded multihash format.\n\nOPTIONS\n\n  --data-encoding  string - Encoding type of the data field, either "text" or\n                            "base64". Default: text.\n\nDESCRIPTION\n\n  \'ipfs object get\' is a plumbing command for retrieving DAG nodes.\n  It serializes the DAG node to the format specified by the "--encoding"\n  flag. It outputs to stdout, and <key> is a base58 encoded multihash.\n  \n  This command outputs data in the following encodings:\n    * "protobuf"\n    * "json"\n    * "xml"\n  (Specified by the "--encoding" or "--enc" flag)\n  \n  The encoding of the object\'s data field can be specified by using the\n  --data-encoding flag\n  \n  Supported values are:\n  \t* "text" (default)\n  \t* "base64"\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-object-links"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-links"}},[e._v("#")]),e._v(" ipfs object links")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object links <key> - Output the links pointed to by the specified object.\n\nSYNOPSIS\n  ipfs object links [--headers | -v] [--] <key>\n\nARGUMENTS\n\n  <key> - Key of the object to retrieve, in base58-encoded multihash format.\n\nOPTIONS\n\n  -v, --headers  bool - Print table headers (Hash, Size, Name).\n\nDESCRIPTION\n\n  'ipfs object links' is a plumbing command for retrieving the links from\n  a DAG node. It outputs to stdout, and <key> is a base58 encoded\n  multihash.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-new"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-new"}},[e._v("#")]),e._v(" ipfs object new")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object new [<template>] - Create a new object from an ipfs template.\n\nSYNOPSIS\n  ipfs object new [--] [<template>]\n\nARGUMENTS\n\n  [<template>] - Template to use. Optional.\n\nDESCRIPTION\n\n  'ipfs object new' is a plumbing command for creating new DAG nodes.\n  By default it creates and returns a new empty merkledag node, but\n  you may pass an optional template argument to create a preformatted\n  node.\n  \n  Available templates:\n  \t* unixfs-dir\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-patch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-patch"}},[e._v("#")]),e._v(" ipfs object patch")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object patch - Create a new merkledag object based on an existing one.\n\nSYNOPSIS\n  ipfs object patch\n\nDESCRIPTION\n\n  'ipfs object patch <root> <cmd> <args>' is a plumbing command used to\n  build custom DAG objects. It mutates objects, creating new objects as a\n  result. This is the Merkle-DAG version of modifying an object.\n\nSUBCOMMANDS\n  ipfs object patch add-link <root> <name> <ref> - Add a link to a given object.\n  ipfs object patch append-data <root> <data>    - Append data to the data segment of a dag node.\n  ipfs object patch rm-link <root> <name>        - Remove a link from a given object.\n  ipfs object patch set-data <root> <data>       - Set the data field of an IPFS object.\n\n  For more information about each command, use:\n  'ipfs object patch <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-patch-add-link"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-patch-add-link"}},[e._v("#")]),e._v(" ipfs object patch add-link")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object patch add-link <root> <name> <ref> - Add a link to a given object.\n\nSYNOPSIS\n  ipfs object patch add-link [--create | -p] [--] <root> <name> <ref>\n\nARGUMENTS\n\n  <root> - The hash of the node to modify.\n  <name> - Name of link to create.\n  <ref>  - IPFS object to add link to.\n\nOPTIONS\n\n  -p, --create  bool - Create intermediary nodes.\n\nDESCRIPTION\n\n  Add a Merkle-link to the given object and return the hash of the result.\n  \n  Example:\n  \n      $ EMPTY_DIR=$(ipfs object new unixfs-dir)\n      $ BAR=$(echo \"bar\" | ipfs add -q)\n      $ ipfs object patch $EMPTY_DIR add-link foo $BAR\n  \n  This takes an empty directory, and adds a link named 'foo' under it, pointing\n  to a file containing 'bar', and returns the hash of the new object.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-patch-append-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-patch-append-data"}},[e._v("#")]),e._v(" ipfs object patch append-data")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs object patch append-data <root> <data> - Append data to the data segment\n                                                of a dag node.\n\nSYNOPSIS\n  ipfs object patch append-data [--] <root> <data>\n\nARGUMENTS\n\n  <root> - The hash of the node to modify.\n  <data> - Data to append.\n\nDESCRIPTION\n\n  Append data to what already exists in the data segment in the given object.\n  \n  Example:\n  \n  \t$ echo "hello" | ipfs object patch $HASH append-data\n  \n  NOTE: This does not append data to a file - it modifies the actual raw\n  data within an object. Objects have a max size of 1MB and objects larger than\n  the limit will not be respected by the network.\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-object-patch-rm-link"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-patch-rm-link"}},[e._v("#")]),e._v(" ipfs object patch rm-link")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object patch rm-link <root> <name> - Remove a link from a given object.\n\nSYNOPSIS\n  ipfs object patch rm-link [--] <root> <name>\n\nARGUMENTS\n\n  <root> - The hash of the node to modify.\n  <name> - Name of the link to remove.\n\nDESCRIPTION\n\n  Remove a Merkle-link from the given object and return the hash of the result.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-object-patch-set-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-patch-set-data"}},[e._v("#")]),e._v(" ipfs object patch set-data")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs object patch set-data <root> <data> - Set the data field of an IPFS\n                                             object.\n\nSYNOPSIS\n  ipfs object patch set-data [--] <root> <data>\n\nARGUMENTS\n\n  <root> - The hash of the node to modify.\n  <data> - The data to set the object to.\n\nDESCRIPTION\n\n  Set the data of an IPFS object from stdin or with the contents of a file.\n  \n  Example:\n  \n      $ echo "my data" | ipfs object patch $MYHASH set-data\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-object-put"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-put"}},[e._v("#")]),e._v(" ipfs object put")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs object put <data> - Store input as a DAG object, print its key.\n\nSYNOPSIS\n  ipfs object put [--inputenc=<inputenc>] [--datafieldenc=<datafieldenc>]\n                  [--pin] [--quiet | -q] [--] <data>\n\nARGUMENTS\n\n  <data> - Data to be stored as a DAG object.\n\nOPTIONS\n\n  --inputenc      string - Encoding type of input data. One of: {"protobuf",\n                           "json"}. Default: json.\n  --datafieldenc  string - Encoding type of the data field, either "text" or\n                           "base64". Default: text.\n  --pin           bool   - Pin this object when adding.\n  -q, --quiet     bool   - Write minimal output.\n\nDESCRIPTION\n\n  \'ipfs object put\' is a plumbing command for storing DAG nodes.\n  It reads from stdin, and the output is a base58 encoded multihash.\n  \n  Data should be in the format specified by the --inputenc flag.\n  --inputenc may be one of the following:\n  \t* "protobuf"\n  \t* "json" (default)\n  \n  Examples:\n  \n  \t$ echo \'{ "Data": "abc" }\' | ipfs object put\n  \n  This creates a node with the data \'abc\' and no links. For an object with\n  links, create a file named \'node.json\' with the contents:\n  \n      {\n          "Data": "another",\n          "Links": [ {\n              "Name": "some link",\n              "Hash": "QmXg9Pp2ytZ14xgmQjYEiHjVjMFXzCVVEcRTWJBmLgR39V",\n              "Size": 8\n          } ]\n      }\n  \n  And then run:\n  \n  \t$ ipfs object put node.json\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-object-stat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-object-stat"}},[e._v("#")]),e._v(" ipfs object stat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs object stat <key> - Get stats for the DAG node named by <key>.\n\nSYNOPSIS\n  ipfs object stat [--human] [--] <key>\n\nARGUMENTS\n\n  <key> - Key of the object to retrieve, in base58-encoded multihash format.\n\nOPTIONS\n\n  --human  bool - Print sizes in human readable format (e.g., 1K 234M 2G).\n\nDESCRIPTION\n\n  'ipfs object stat' is a plumbing command to print DAG node statistics.\n  <key> is a base58 encoded multihash. It outputs to stdout:\n  \n  \tNumLinks        int number of links in link table\n  \tBlockSize       int size of the raw, encoded data\n  \tLinksSize       int size of the links segment\n  \tDataSize        int size of the data segment\n  \tCumulativeSize  int cumulative size of object and its references\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p"}},[e._v("#")]),e._v(" ipfs p2p")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p - Libp2p stream mounting.\n\nSYNOPSIS\n  ipfs p2p\n\nDESCRIPTION\n\n  Create and use tunnels to remote peers over libp2p\n  \n  Note: this command is experimental and subject to change as usecases and APIs\n  are refined\n\nSUBCOMMANDS\n  ipfs p2p close                                                - Stop listening for new connections to forward.\n  ipfs p2p forward <protocol> <listen-address> <target-address> - Forward connections to libp2p service\n  ipfs p2p listen <protocol> <target-address>                   - Create libp2p service\n  ipfs p2p ls                                                   - List active p2p listeners.\n  ipfs p2p stream                                               - P2P stream management.\n\n  For more information about each command, use:\n  'ipfs p2p <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-close"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-close"}},[e._v("#")]),e._v(" ipfs p2p close")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p close - Stop listening for new connections to forward.\n\nSYNOPSIS\n  ipfs p2p close [--all | -a] [--protocol=<protocol> | -p]\n                 [--listen-address=<listen-address> | -l]\n                 [--target-address=<target-address> | -t]\n\nOPTIONS\n\n  -a, --all             bool   - Close all listeners.\n  -p, --protocol        string - Match protocol name.\n  -l, --listen-address  string - Match listen address.\n  -t, --target-address  string - Match target address.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-forward"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-forward"}},[e._v("#")]),e._v(" ipfs p2p forward")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p forward <protocol> <listen-address> <target-address> - Forward connections to libp2p service\n\nSYNOPSIS\n  ipfs p2p forward [--allow-custom-protocol] [--] <protocol> <listen-address>\n                   <target-address>\n\nARGUMENTS\n\n  <protocol>       - Protocol name.\n  <listen-address> - Listening endpoint.\n  <target-address> - Target endpoint.\n\nOPTIONS\n\n  --allow-custom-protocol  bool - Don't require /x/ prefix.\n\nDESCRIPTION\n\n  Forward connections made to <listen-address> to <target-address>.\n  \n  <protocol> specifies the libp2p protocol name to use for libp2p\n  connections and/or handlers. It must be prefixed with '/x/'.\n  \n  Example:\n    ipfs p2p forward /x/myproto /ip4/127.0.0.1/tcp/4567 /p2p/QmPeer\n      - Forward connections to 127.0.0.1:4567 to '/x/myproto' service on /p2p/QmPeer\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-listen"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-listen"}},[e._v("#")]),e._v(" ipfs p2p listen")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p listen <protocol> <target-address> - Create libp2p service\n\nSYNOPSIS\n  ipfs p2p listen [--allow-custom-protocol] [--report-peer-id | -r] [--]\n                  <protocol> <target-address>\n\nARGUMENTS\n\n  <protocol>       - Protocol name.\n  <target-address> - Target endpoint.\n\nOPTIONS\n\n  --allow-custom-protocol  bool - Don't require /x/ prefix.\n  -r, --report-peer-id     bool - Send remote base58 peerid to target when a\n                                  new connection is established.\n\nDESCRIPTION\n\n  Create libp2p service and forward connections made to <target-address>.\n  \n  <protocol> specifies the libp2p handler name. It must be prefixed with '/x/'.\n  \n  Example:\n    ipfs p2p listen /x/myproto /ip4/127.0.0.1/tcp/1234\n      - Forward connections to 'myproto' libp2p service to 127.0.0.1:1234\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-ls"}},[e._v("#")]),e._v(" ipfs p2p ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p ls - List active p2p listeners.\n\nSYNOPSIS\n  ipfs p2p ls [--headers | -v]\n\nOPTIONS\n\n  -v, --headers  bool - Print table headers (Protocol, Listen, Target).\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-stream"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-stream"}},[e._v("#")]),e._v(" ipfs p2p stream")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p stream - P2P stream management.\n\nSYNOPSIS\n  ipfs p2p stream\n\nDESCRIPTION\n\n  Create and manage p2p streams\n\nSUBCOMMANDS\n  ipfs p2p stream close [<id>] - Close active p2p stream.\n  ipfs p2p stream ls           - List active p2p streams.\n\n  For more information about each command, use:\n  'ipfs p2p stream <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-stream-close"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-stream-close"}},[e._v("#")]),e._v(" ipfs p2p stream close")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p stream close [<id>] - Close active p2p stream.\n\nSYNOPSIS\n  ipfs p2p stream close [--all | -a] [--] [<id>]\n\nARGUMENTS\n\n  [<id>] - Stream identifier\n\nOPTIONS\n\n  -a, --all  bool - Close all streams.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-p2p-stream-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-p2p-stream-ls"}},[e._v("#")]),e._v(" ipfs p2p stream ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs p2p stream ls - List active p2p streams.\n\nSYNOPSIS\n  ipfs p2p stream ls [--headers | -v]\n\nOPTIONS\n\n  -v, --headers  bool - Print table headers (ID, Protocol, Local, Remote).\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pin"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pin"}},[e._v("#")]),e._v(" ipfs pin")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pin - Pin (and unpin) objects to local storage.\n\nSYNOPSIS\n  ipfs pin\n\nSUBCOMMANDS\n  ipfs pin add <ipfs-path>...           - Pin objects to local storage.\n  ipfs pin ls [<ipfs-path>]...          - List objects pinned to local storage.\n  ipfs pin rm <ipfs-path>...            - Remove pinned objects from local\n                                          storage.\n  ipfs pin update <from-path> <to-path> - Update a recursive pin\n  ipfs pin verify                       - Verify that recursive pins are\n                                          complete.\n\n  For more information about each command, use:\n  'ipfs pin <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-pin-add"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pin-add"}},[e._v("#")]),e._v(" ipfs pin add")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pin add <ipfs-path>... - Pin objects to local storage.\n\nSYNOPSIS\n  ipfs pin add [--recursive=false] [--progress] [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - Path to object(s) to be pinned.\n\nOPTIONS\n\n  -r, --recursive  bool - Recursively pin the object linked to by the specified\n                          object(s). Default: true.\n  --progress       bool - Show progress.\n\nDESCRIPTION\n\n  Stores an IPFS object(s) from a given path locally to disk.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pin-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pin-ls"}},[e._v("#")]),e._v(" ipfs pin ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs pin ls [<ipfs-path>]... - List objects pinned to local storage.\n\nSYNOPSIS\n  ipfs pin ls [--type=<type> | -t] [--quiet | -q] [--stream | -s] [--]\n              [<ipfs-path>...]\n\nARGUMENTS\n\n  [<ipfs-path>]... - Path to object(s) to be listed.\n\nOPTIONS\n\n  -t, --type    string - The type of pinned keys to list. Can be "direct",\n                         "indirect", "recursive", or "all". Default: all.\n  -q, --quiet   bool   - Write just hashes of objects.\n  -s, --stream  bool   - Enable streaming of pins as they are discovered.\n\nDESCRIPTION\n\n  Returns a list of objects that are pinned locally.\n  By default, all pinned objects are returned, but the \'--type\' flag or\n  arguments can restrict that to a specific pin type or to some specific objects\n  respectively.\n  \n  Use --type=<type> to specify the type of pinned keys to list.\n  Valid values are:\n      * "direct": pin that specific object.\n      * "recursive": pin that specific object, and indirectly pin all its\n      \tdescendants\n      * "indirect": pinned indirectly by an ancestor (like a refcount)\n      * "all"\n  \n  With arguments, the command fails if any of the arguments is not a pinned\n  object. And if --type=<type> is additionally used, the command will also fail\n  if any of the arguments is not of the specified type.\n  \n  Example:\n  \t$ echo "hello" | ipfs add -q\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \t$ ipfs pin ls\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN recursive\n  \t# now remove the pin, and repin it directly\n  \t$ ipfs pin rm QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \tunpinned QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \t$ ipfs pin add -r=false QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \tpinned QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN directly\n  \t$ ipfs pin ls --type=direct\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN direct\n  \t$ ipfs pin ls QmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN\n  \tQmZULkCELmmk5XNfCgTnCyFgAVxBRBXyDHGGMVoLFLiXEN direct\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-pin-rm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pin-rm"}},[e._v("#")]),e._v(" ipfs pin rm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pin rm <ipfs-path>... - Remove pinned objects from local storage.\n\nSYNOPSIS\n  ipfs pin rm [--recursive=false] [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - Path to object(s) to be unpinned.\n\nOPTIONS\n\n  -r, --recursive  bool - Recursively unpin the object linked to by the\n                          specified object(s). Default: true.\n\nDESCRIPTION\n\n  Removes the pin from the given object allowing it to be garbage\n  collected if needed. (By default, recursively. Use -r=false for direct pins.)\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pin-update"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pin-update"}},[e._v("#")]),e._v(" ipfs pin update")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pin update <from-path> <to-path> - Update a recursive pin\n\nSYNOPSIS\n  ipfs pin update [--unpin=false] [--] <from-path> <to-path>\n\nARGUMENTS\n\n  <from-path> - Path to old object.\n  <to-path>   - Path to a new object to be pinned.\n\nOPTIONS\n\n  --unpin  bool - Remove the old pin. Default: true.\n\nDESCRIPTION\n\n  Efficiently pins a new object based on differences from an existing one and,\n  by default, removes the old pin.\n  \n  This command is useful when the new pin contains many similarities or is a\n  derivative of an existing one, particularly for large objects. This allows a more\n  efficient DAG-traversal which fully skips already-pinned branches from the old\n  object. As a requirement, the old object needs to be an existing recursive\n  pin.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pin-verify"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pin-verify"}},[e._v("#")]),e._v(" ipfs pin verify")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pin verify - Verify that recursive pins are complete.\n\nSYNOPSIS\n  ipfs pin verify [--verbose] [--quiet | -q]\n\nOPTIONS\n\n  --verbose    bool - Also write the hashes of non-broken pins.\n  -q, --quiet  bool - Write just hashes of broken pins.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-ping"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-ping"}},[e._v("#")]),e._v(" ipfs ping")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs ping <peer ID>... - Send echo request packets to IPFS hosts.\n\nSYNOPSIS\n  ipfs ping [--count=<count> | -n] [--] <peer ID>...\n\nARGUMENTS\n\n  <peer ID>... - ID of peer to be pinged.\n\nOPTIONS\n\n  -n, --count  int - Number of ping messages to send. Default: 10.\n\nDESCRIPTION\n\n  'ipfs ping' is a tool to test sending data to other nodes. It finds nodes\n  via the routing system, sends pings, waits for pongs, and prints out round-\n  trip latency information.\n  \t\t\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pubsub"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pubsub"}},[e._v("#")]),e._v(" ipfs pubsub")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pubsub - An experimental publish-subscribe system on ipfs.\n\nSYNOPSIS\n  ipfs pubsub\n\nDESCRIPTION\n\n  ipfs pubsub allows you to publish messages to a given topic, and also to\n  subscribe to new messages on a given topic.\n  \n  This is an experimental feature. It is not intended in its current state\n  to be used in a production environment.\n  \n  To use, the daemon must be run with '--enable-pubsub-experiment'.\n\nSUBCOMMANDS\n  ipfs pubsub ls                    - List subscribed topics by name.\n  ipfs pubsub peers [<topic>]       - List peers we are currently pubsubbing\n                                      with.\n  ipfs pubsub pub <topic> <data>... - Publish a message to a given pubsub topic.\n  ipfs pubsub sub <topic>           - Subscribe to messages on a given topic.\n\n  For more information about each command, use:\n  'ipfs pubsub <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-pubsub-ls"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pubsub-ls"}},[e._v("#")]),e._v(" ipfs pubsub ls")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pubsub ls - List subscribed topics by name.\n\nSYNOPSIS\n  ipfs pubsub ls\n\nDESCRIPTION\n\n  ipfs pubsub ls lists out the names of topics you are currently subscribed to.\n  \n  This is an experimental feature. It is not intended in its current state\n  to be used in a production environment.\n  \n  To use, the daemon must be run with '--enable-pubsub-experiment'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pubsub-peers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pubsub-peers"}},[e._v("#")]),e._v(" ipfs pubsub peers")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pubsub peers [<topic>] - List peers we are currently pubsubbing with.\n\nSYNOPSIS\n  ipfs pubsub peers [--] [<topic>]\n\nARGUMENTS\n\n  [<topic>] - topic to list connected peers of\n\nDESCRIPTION\n\n  ipfs pubsub peers with no arguments lists out the pubsub peers you are\n  currently connected to. If given a topic, it will list connected\n  peers who are subscribed to the named topic.\n  \n  This is an experimental feature. It is not intended in its current state\n  to be used in a production environment.\n  \n  To use, the daemon must be run with '--enable-pubsub-experiment'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pubsub-pub"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pubsub-pub"}},[e._v("#")]),e._v(" ipfs pubsub pub")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs pubsub pub <topic> <data>... - Publish a message to a given pubsub topic.\n\nSYNOPSIS\n  ipfs pubsub pub [--] <topic> <data>...\n\nARGUMENTS\n\n  <topic>   - Topic to publish to.\n  <data>... - Payload of message to publish.\n\nDESCRIPTION\n\n  ipfs pubsub pub publishes a message to a specified topic.\n  \n  This is an experimental feature. It is not intended in its current state\n  to be used in a production environment.\n  \n  To use, the daemon must be run with '--enable-pubsub-experiment'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-pubsub-sub"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-pubsub-sub"}},[e._v("#")]),e._v(" ipfs pubsub sub")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs pubsub sub <topic> - Subscribe to messages on a given topic.\n\nSYNOPSIS\n  ipfs pubsub sub [--discover] [--] <topic>\n\nARGUMENTS\n\n  <topic> - String name of topic to subscribe to.\n\nOPTIONS\n\n  --discover  bool - try to discover other peers subscribed to the same topic.\n\nDESCRIPTION\n\n  ipfs pubsub sub subscribes to messages on a given topic.\n  \n  This is an experimental feature. It is not intended in its current state\n  to be used in a production environment.\n  \n  To use, the daemon must be run with \'--enable-pubsub-experiment\'.\n  \n  This command outputs data in the following encodings:\n    * "json"\n  (Specified by the "--encoding" or "--enc" flag)\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-refs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-refs"}},[e._v("#")]),e._v(" ipfs refs")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs refs <ipfs-path>... - List links (references) from an object.\n\nSYNOPSIS\n  ipfs refs [--format=<format>] [--edges | -e] [--unique | -u]\n            [--recursive | -r] [--max-depth=<max-depth>] [--] <ipfs-path>...\n\nARGUMENTS\n\n  <ipfs-path>... - Path to the object(s) to list refs from.\n\nOPTIONS\n\n  --format         string - Emit edges with given format. Available tokens:\n                            <src> <dst> <linkname>. Default: <dst>.\n  -e, --edges      bool   - Emit edge format: `<from> -> <to>`.\n  -u, --unique     bool   - Omit duplicate refs from output.\n  -r, --recursive  bool   - Recursively list links of child nodes.\n  --max-depth      int    - Only for recursive refs, limits fetch and listing\n                            to the given depth. Default: -1.\n\nDESCRIPTION\n\n  Lists the hashes of all the links an IPFS or IPNS object(s) contains,\n  with the following format:\n  \n    <link base58 hash>\n  \n  NOTE: List all references recursively by using the flag '-r'.\n\nSUBCOMMANDS\n  ipfs refs local - List all local references.\n\n  For more information about each command, use:\n  'ipfs refs <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-refs-local"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-refs-local"}},[e._v("#")]),e._v(" ipfs refs local")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs refs local - List all local references.\n\nSYNOPSIS\n  ipfs refs local\n\nDESCRIPTION\n\n  Displays the hashes of all local objects.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-repo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-repo"}},[e._v("#")]),e._v(" ipfs repo")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs repo - Manipulate the IPFS repo.\n\nSYNOPSIS\n  ipfs repo\n\nDESCRIPTION\n\n  'ipfs repo' is a plumbing command used to manipulate the repo.\n\nSUBCOMMANDS\n  ipfs repo fsck    - Remove repo lockfiles.\n  ipfs repo gc      - Perform a garbage collection sweep on the repo.\n  ipfs repo stat    - Get stats for the currently used repo.\n  ipfs repo verify  - Verify all blocks in repo are not corrupted.\n  ipfs repo version - Show the repo version.\n\n  For more information about each command, use:\n  'ipfs repo <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-repo-fsck"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-repo-fsck"}},[e._v("#")]),e._v(" ipfs repo fsck")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs repo fsck - Remove repo lockfiles.\n\nSYNOPSIS\n  ipfs repo fsck\n\nDESCRIPTION\n\n  'ipfs repo fsck' is now a no-op.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-repo-gc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-repo-gc"}},[e._v("#")]),e._v(" ipfs repo gc")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs repo gc - Perform a garbage collection sweep on the repo.\n\nSYNOPSIS\n  ipfs repo gc [--stream-errors] [--quiet | -q]\n\nOPTIONS\n\n  --stream-errors  bool - Stream errors.\n  -q, --quiet      bool - Write minimal output.\n\nDESCRIPTION\n\n  'ipfs repo gc' is a plumbing command that will sweep the local\n  set of stored objects and remove ones that are not pinned in\n  order to reclaim hard disk space.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-repo-stat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-repo-stat"}},[e._v("#")]),e._v(" ipfs repo stat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs repo stat - Get stats for the currently used repo.\n\nSYNOPSIS\n  ipfs repo stat [--size-only | -s] [--human | -H]\n\nOPTIONS\n\n  -s, --size-only  bool - Only report RepoSize and StorageMax.\n  -H, --human      bool - Print sizes in human readable format (e.g., 1K 234M\n                          2G).\n\nDESCRIPTION\n\n  'ipfs repo stat' provides information about the local set of\n  stored objects. It outputs:\n  \n  RepoSize        int Size in bytes that the repo is currently taking.\n  StorageMax      string Maximum datastore size (from configuration)\n  NumObjects      int Number of objects in the local repo.\n  RepoPath        string The path to the repo being currently used.\n  Version         string The repo version.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-repo-verify"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-repo-verify"}},[e._v("#")]),e._v(" ipfs repo verify")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs repo verify - Verify all blocks in repo are not corrupted.\n\nSYNOPSIS\n  ipfs repo verify\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-repo-version"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-repo-version"}},[e._v("#")]),e._v(" ipfs repo version")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs repo version - Show the repo version.\n\nSYNOPSIS\n  ipfs repo version [--quiet | -q]\n\nOPTIONS\n\n  -q, --quiet  bool - Write minimal output.\n\nDESCRIPTION\n\n  'ipfs repo version' returns the current repo version.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-resolve"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-resolve"}},[e._v("#")]),e._v(" ipfs resolve")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs resolve <name> - Resolve the value of names to IPFS.\n\nSYNOPSIS\n  ipfs resolve [--recursive=false]\n               [--dht-record-count=<dht-record-count> | --dhtrc]\n               [--dht-timeout=<dht-timeout> | --dhtt] [--] <name>\n\nARGUMENTS\n\n  <name> - The name to resolve.\n\nOPTIONS\n\n  -r, --recursive              bool   - Resolve until the result is an IPFS\n                                        name. Default: true.\n  --dhtrc, --dht-record-count  int    - Number of records to request for DHT\n                                        resolution.\n  --dhtt, --dht-timeout        string - Max time to collect values during DHT\n                                        resolution eg "30s". Pass 0 for no\n                                        timeout.\n\nDESCRIPTION\n\n  There are a number of mutable name protocols that can link among\n  themselves and into IPNS. For example IPNS references can (currently)\n  point at an IPFS object, and DNS links can point at other DNS links, IPNS\n  entries, or IPFS objects. This command accepts any of these\n  identifiers and resolves them to the referenced item.\n  \n  EXAMPLES\n  \n  Resolve the value of your identity:\n  \n    $ ipfs resolve /ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n    /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n  \n  Resolve the value of another name:\n  \n    $ ipfs resolve /ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n\n    /ipns/QmatmE9msSfkKxoffpHwNLNKgwZG8eT9Bud6YoPab52vpy\n  \n  Resolve the value of another name recursively:\n  \n    $ ipfs resolve -r /ipns/QmbCMUZw6JFeZ7Wp9jkzbye3Fzp2GGcPgC3nmeUjfVF87n\n    /ipfs/Qmcqtw8FfrVSBaRmbWwHxt3AuySBhJLcvmFYi3Lbc4xnwj\n  \n  Resolve the value of an IPFS DAG path:\n  \n    $ ipfs resolve /ipfs/QmeZy1fGbwgVSrqbfh9fKQrAWgeyRnj7h8fsHS1oy3k99x/beep/boop\n    /ipfs/QmYRMjyvAiHKN9UTi8Bzt1HUspmSRD8T8DwxfSMzLgBon1\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-shutdown"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-shutdown"}},[e._v("#")]),e._v(" ipfs shutdown")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs shutdown - Shut down the ipfs daemon\n\nSYNOPSIS\n  ipfs shutdown\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-stats"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-stats"}},[e._v("#")]),e._v(" ipfs stats")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs stats - Query IPFS statistics.\n\nSYNOPSIS\n  ipfs stats\n\nDESCRIPTION\n\n  'ipfs stats' is a set of commands to help look at statistics\n  for your IPFS node.\n\nSUBCOMMANDS\n  ipfs stats bitswap - Show some diagnostic information on the bitswap agent.\n  ipfs stats bw      - Print ipfs bandwidth information.\n  ipfs stats repo    - Get stats for the currently used repo.\n\n  For more information about each command, use:\n  'ipfs stats <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-stats-bitswap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-stats-bitswap"}},[e._v("#")]),e._v(" ipfs stats bitswap")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs stats bitswap - Show some diagnostic information on the bitswap agent.\n\nSYNOPSIS\n  ipfs stats bitswap [--verbose | -v] [--human]\n\nOPTIONS\n\n  -v, --verbose  bool - Print extra information.\n  --human        bool - Print sizes in human readable format (e.g., 1K 234M 2G).\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-stats-bw"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-stats-bw"}},[e._v("#")]),e._v(" ipfs stats bw")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('USAGE\n  ipfs stats bw - Print ipfs bandwidth information.\n\nSYNOPSIS\n  ipfs stats bw [--peer=<peer> | -p] [--proto=<proto> | -t] [--poll]\n                [--interval=<interval> | -i]\n\nOPTIONS\n\n  -p, --peer      string - Specify a peer to print bandwidth for.\n  -t, --proto     string - Specify a protocol to print bandwidth for.\n  --poll          bool   - Print bandwidth at an interval.\n  -i, --interval  string - Time interval to wait between updating output, if\n                           \'poll\' is true.\n  \n      This accepts durations such as\n                           "300s", "1.5h" or "2h45m". Valid time units are:\n     \n                           "ns", "us" (or "µs"), "ms", "s", "m", "h". Default:\n                           1s.\n\nDESCRIPTION\n\n  \'ipfs stats bw\' prints bandwidth information for the ipfs daemon.\n  It displays: TotalIn, TotalOut, RateIn, RateOut.\n  \n  By default, overall bandwidth and all protocols are shown. To limit bandwidth\n  to a particular peer, use the \'peer\' option along with that peer\'s multihash\n  id. To specify a specific protocol, use the \'proto\' option. The \'peer\' and\n  \'proto\' options cannot be specified simultaneously. The protocols that are\n  queried using this method are outlined in the specification:\n  https://github.com/libp2p/specs/blob/master/7-properties.md#757-protocol-multicodecs\n  \n  Example protocol options:\n    - /ipfs/id/1.0.0\n    - /ipfs/bitswap\n    - /ipfs/dht\n  \n  Example:\n  \n      > ipfs stats bw -t /ipfs/bitswap\n      Bandwidth\n      TotalIn: 5.0MB\n      TotalOut: 0B\n      RateIn: 343B/s\n      RateOut: 0B/s\n      > ipfs stats bw -p QmepgFW7BHEtU4pZJdxaNiv75mKLLRQnPi1KaaXmQN4V1a\n      Bandwidth\n      TotalIn: 4.9MB\n      TotalOut: 12MB\n      RateIn: 0B/s\n      RateOut: 0B/s\n\n\n')])])]),s("h2",{attrs:{id:"ipfs-stats-repo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-stats-repo"}},[e._v("#")]),e._v(" ipfs stats repo")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs stats repo - Get stats for the currently used repo.\n\nSYNOPSIS\n  ipfs stats repo [--size-only | -s] [--human | -H]\n\nOPTIONS\n\n  -s, --size-only  bool - Only report RepoSize and StorageMax.\n  -H, --human      bool - Print sizes in human readable format (e.g., 1K 234M\n                          2G).\n\nDESCRIPTION\n\n  'ipfs repo stat' provides information about the local set of\n  stored objects. It outputs:\n  \n  RepoSize        int Size in bytes that the repo is currently taking.\n  StorageMax      string Maximum datastore size (from configuration)\n  NumObjects      int Number of objects in the local repo.\n  RepoPath        string The path to the repo being currently used.\n  Version         string The repo version.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm"}},[e._v("#")]),e._v(" ipfs swarm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm - Interact with the swarm.\n\nSYNOPSIS\n  ipfs swarm\n\nDESCRIPTION\n\n  'ipfs swarm' is a tool to manipulate the network swarm. The swarm is the\n  component that opens, listens for, and maintains connections to other\n  ipfs peers in the internet.\n\nSUBCOMMANDS\n  ipfs swarm addrs                   - List known addresses. Useful for\n                                       debugging.\n  ipfs swarm connect <address>...    - Open connection to a given address.\n  ipfs swarm disconnect <address>... - Close connection to a given address.\n  ipfs swarm filters                 - Manipulate address filters.\n  ipfs swarm peers                   - List peers with open connections.\n\n  For more information about each command, use:\n  'ipfs swarm <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-addrs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-addrs"}},[e._v("#")]),e._v(" ipfs swarm addrs")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm addrs - List known addresses. Useful for debugging.\n\nSYNOPSIS\n  ipfs swarm addrs\n\nDESCRIPTION\n\n  'ipfs swarm addrs' lists all addresses this node is aware of.\n\nSUBCOMMANDS\n  ipfs swarm addrs listen - List interface listening addresses.\n  ipfs swarm addrs local  - List local addresses.\n\n  For more information about each command, use:\n  'ipfs swarm addrs <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-addrs-listen"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-addrs-listen"}},[e._v("#")]),e._v(" ipfs swarm addrs listen")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm addrs listen - List interface listening addresses.\n\nSYNOPSIS\n  ipfs swarm addrs listen\n\nDESCRIPTION\n\n  'ipfs swarm addrs listen' lists all interface addresses the node is listening on.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-addrs-local"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-addrs-local"}},[e._v("#")]),e._v(" ipfs swarm addrs local")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm addrs local - List local addresses.\n\nSYNOPSIS\n  ipfs swarm addrs local [--id]\n\nOPTIONS\n\n  --id  bool - Show peer ID in addresses.\n\nDESCRIPTION\n\n  'ipfs swarm addrs local' lists all local listening addresses announced to the network.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-connect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-connect"}},[e._v("#")]),e._v(" ipfs swarm connect")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm connect <address>... - Open connection to a given address.\n\nSYNOPSIS\n  ipfs swarm connect [--] <address>...\n\nARGUMENTS\n\n  <address>... - Address of peer to connect to.\n\nDESCRIPTION\n\n  'ipfs swarm connect' opens a new direct connection to a peer address.\n  \n  The address format is an IPFS multiaddr:\n  \n  ipfs swarm connect /ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-disconnect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-disconnect"}},[e._v("#")]),e._v(" ipfs swarm disconnect")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm disconnect <address>... - Close connection to a given address.\n\nSYNOPSIS\n  ipfs swarm disconnect [--] <address>...\n\nARGUMENTS\n\n  <address>... - Address of peer to disconnect from.\n\nDESCRIPTION\n\n  'ipfs swarm disconnect' closes a connection to a peer address. The address\n  format is an IPFS multiaddr:\n  \n  ipfs swarm disconnect /ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ\n  \n  The disconnect is not permanent; if ipfs needs to talk to that address later,\n  it will reconnect.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-filters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-filters"}},[e._v("#")]),e._v(" ipfs swarm filters")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm filters - Manipulate address filters.\n\nSYNOPSIS\n  ipfs swarm filters\n\nDESCRIPTION\n\n  'ipfs swarm filters' will list out currently applied filters. Its subcommands\n  can be used to add or remove said filters. Filters are specified using the\n  multiaddr-filter format:\n  \n  Example:\n  \n      /ip4/192.168.0.0/ipcidr/16\n  \n  Where the above is equivalent to the standard CIDR:\n  \n      192.168.0.0/16\n  \n  Filters default to those specified under the \"Swarm.AddrFilters\" config key.\n\nSUBCOMMANDS\n  ipfs swarm filters add <address>... - Add an address filter.\n  ipfs swarm filters rm <address>...  - Remove an address filter.\n\n  For more information about each command, use:\n  'ipfs swarm filters <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-filters-add"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-filters-add"}},[e._v("#")]),e._v(" ipfs swarm filters add")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm filters add <address>... - Add an address filter.\n\nSYNOPSIS\n  ipfs swarm filters add [--] <address>...\n\nARGUMENTS\n\n  <address>... - Multiaddr to filter.\n\nDESCRIPTION\n\n  'ipfs swarm filters add' will add an address filter to the daemons swarm.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-filters-rm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-filters-rm"}},[e._v("#")]),e._v(" ipfs swarm filters rm")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm filters rm <address>... - Remove an address filter.\n\nSYNOPSIS\n  ipfs swarm filters rm [--] <address>...\n\nARGUMENTS\n\n  <address>... - Multiaddr filter to remove.\n\nDESCRIPTION\n\n  'ipfs swarm filters rm' will remove an address filter from the daemons swarm.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-swarm-peers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-swarm-peers"}},[e._v("#")]),e._v(" ipfs swarm peers")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs swarm peers - List peers with open connections.\n\nSYNOPSIS\n  ipfs swarm peers [--verbose | -v] [--streams] [--latency] [--direction]\n\nOPTIONS\n\n  -v, --verbose  bool - display all extra information.\n  --streams      bool - Also list information about open streams for each peer.\n  --latency      bool - Also list information about latency to each peer.\n  --direction    bool - Also list information about the direction of connection.\n\nDESCRIPTION\n\n  'ipfs swarm peers' lists the set of peers this node is connected to.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-tar"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-tar"}},[e._v("#")]),e._v(" ipfs tar")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs tar - Utility functions for tar files in ipfs.\n\nSYNOPSIS\n  ipfs tar\n\nSUBCOMMANDS\n  ipfs tar add <file> - Import a tar file into ipfs.\n  ipfs tar cat <path> - Export a tar file from IPFS.\n\n  For more information about each command, use:\n  'ipfs tar <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-tar-add"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-tar-add"}},[e._v("#")]),e._v(" ipfs tar add")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs tar add <file> - Import a tar file into ipfs.\n\nSYNOPSIS\n  ipfs tar add [--] <file>\n\nARGUMENTS\n\n  <file> - Tar file to add.\n\nDESCRIPTION\n\n  'ipfs tar add' will parse a tar file and create a merkledag structure to\n  represent it.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-tar-cat"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-tar-cat"}},[e._v("#")]),e._v(" ipfs tar cat")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs tar cat <path> - Export a tar file from IPFS.\n\nSYNOPSIS\n  ipfs tar cat [--] <path>\n\nARGUMENTS\n\n  <path> - ipfs path of archive to export.\n\nDESCRIPTION\n\n  'ipfs tar cat' will export a tar file from a previously imported one in IPFS.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-update"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-update"}},[e._v("#")]),e._v(" ipfs update")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("NAME:\n   ipfs-update - Update ipfs.\n\nUSAGE:\n   ipfs-update [global options] command [command options] [arguments...]\n\nVERSION:\n   1.6.0\n\nCOMMANDS:\n   versions  Print out all available versions.\n   version   Print out currently installed version.\n   install   Install a version of ipfs.\n   stash     stashes copy of currently installed ipfs binary\n   revert    Revert to previously installed version of ipfs.\n   fetch     Fetch a given version of ipfs. Default: latest.\n   help, h   Shows a list of commands or help for one command\n\nGLOBAL OPTIONS:\n   --verbose         Print verbose output.\n   --distpath value  specify the distributions build to use\n   --help, -h        show help\n   --version, -v     print the version\n")])])]),s("h2",{attrs:{id:"ipfs-urlstore"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-urlstore"}},[e._v("#")]),e._v(" ipfs urlstore")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs urlstore - Interact with urlstore.\n\nSYNOPSIS\n  ipfs urlstore\n\nSUBCOMMANDS\n  ipfs urlstore add <url> - Add URL via urlstore.\n\n  For more information about each command, use:\n  'ipfs urlstore <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-urlstore-add"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-urlstore-add"}},[e._v("#")]),e._v(" ipfs urlstore add")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs urlstore add <url> - Add URL via urlstore.\n\nSYNOPSIS\n  ipfs urlstore add [--trickle | -t] [--pin=false] [--] <url>\n\nARGUMENTS\n\n  <url> - URL to add to IPFS\n\nOPTIONS\n\n  -t, --trickle  bool - Use trickle-dag format for dag generation.\n  --pin          bool - Pin this object when adding. Default: true.\n\nDESCRIPTION\n\n  DEPRECATED: Use 'ipfs add --nocopy --cid-version=1 URL'.\n  \n  Add URLs to ipfs without storing the data locally.\n  \n  The URL provided must be stable and ideally on a web server under your\n  control.\n  \n  The file is added using raw-leaves but otherwise using the default\n  settings for 'ipfs add'.\n\n\n")])])]),s("h2",{attrs:{id:"ipfs-version"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-version"}},[e._v("#")]),e._v(" ipfs version")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs version - Show ipfs version information.\n\nSYNOPSIS\n  ipfs version [--number | -n] [--commit] [--repo] [--all]\n\nOPTIONS\n\n  -n, --number  bool - Only show the version number.\n  --commit      bool - Show the commit hash.\n  --repo        bool - Show repo version.\n  --all         bool - Show all version information.\n\nDESCRIPTION\n\n  Returns the current version of ipfs and exits.\n\nSUBCOMMANDS\n  ipfs version deps - Shows information about dependencies used for build\n\n  For more information about each command, use:\n  'ipfs version <subcmd> --help'\n\n")])])]),s("h2",{attrs:{id:"ipfs-version-deps"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ipfs-version-deps"}},[e._v("#")]),e._v(" ipfs version deps")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("USAGE\n  ipfs version deps - Shows information about dependencies used for build\n\nSYNOPSIS\n  ipfs version deps\n\nDESCRIPTION\n\n  Print out all dependencies and their versions.\n\n\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);