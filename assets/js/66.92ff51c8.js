(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{459:function(e,t,a){"use strict";a.r(t);var s=a(18),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#features"}},[e._v("#")]),e._v(" Features")]),e._v(" "),a("p",[e._v("This release is the biggest Go-IPFS release since the IPFS alpha in February 2015. Here are some of the incredible features we've packed in:")]),e._v(" "),a("h2",{attrs:{id:"improved-dht"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#improved-dht"}},[e._v("#")]),e._v(" Improved DHT")]),e._v(" "),a("p",[e._v("The distributed hash table (DHT) is how IPFS nodes keep track of who has what data. The DHT implementation has been almost completely rewritten in this release. Providing, finding content, and resolving IPNS records are now all much faster. However, there are risks involved with this update due to the significant amount of changes that have gone into this feature.")]),e._v(" "),a("h3",{attrs:{id:"old-and-new"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#old-and-new"}},[e._v("#")]),e._v(" Old and new")]),e._v(" "),a("p",[e._v("Through our research and analysis, we found the old DHT suffers from three core issues addressed in this release:")]),e._v(" "),a("ul",[a("li",[e._v("Most peers in the DHT are undialable (e.g., due to firewalls and NATs). Therefore, much of a DHT query time is wasted trying to connect to peers that cannot be reached.")]),e._v(" "),a("li",[e._v("The DHT query logic doesn't properly terminate when it hits the end of the query and, instead, aggressively keeps on searching until it exhausts all possible routes.")]),e._v(" "),a("li",[e._v("The routing tables are poorly maintained. This can cause a search that should be logarithmic in the size of the network to be linear.")])]),e._v(" "),a("h4",{attrs:{id:"reachability"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reachability"}},[e._v("#")]),e._v(" Reachability")]),e._v(" "),a("p",[e._v("We have addressed the problem of undialable nodes by having nodes wait to join the DHT as "),a("em",[e._v("server")]),e._v(" nodes until they've confirmed that they are reachable from the public internet.")]),e._v(" "),a("p",[e._v("To ensure that nodes which are not publicly reachable (ex behind VPNs, offline LANs, etc.) can still coordinate and share data, Go-IPFS 0.5 will run two DHTs: one for private networks and one for the public internet. Every node will participate in a LAN DHT and a public WAN DHT. See "),a("a",{attrs:{href:"#dual-dht"}},[e._v("Dual DHT")]),e._v(" for more details.")]),e._v(" "),a("h4",{attrs:{id:"dual-dht"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dual-dht"}},[e._v("#")]),e._v(" Dual DHT")]),e._v(" "),a("p",[e._v("All IPFS nodes will now run two DHTs: one for the public internet WAN, and one for their local network LAN.")]),e._v(" "),a("ol",[a("li",[e._v("When connected to the public internet, IPFS will use both DHTs for finding peers, content, and IPNS records. Nodes only publish provider and IPNS records to the WAN DHT to avoid flooding the local network.")]),e._v(" "),a("li",[e._v("When not connected to the public internet, nodes publish provider and IPNS records to the LAN DHT.")])]),e._v(" "),a("p",[e._v("The WAN DHT includes all peers with at least one public IP address. This release will only consider an IPv6 address public if it is in the "),a("a",{attrs:{href:"https://www.iana.org/assignments/ipv6-address-space/ipv6-address-space.xhtml",target:"_blank",rel:"noopener noreferrer"}},[e._v("public internet range "),a("code",[e._v("2000::/3")]),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("p",[e._v("This feature should not have any noticeable impact on Go-IPFS, performance, or otherwise. Everything should continue to work in all the currently supported network configurations: VPNs, disconnected LANs, public internet, etc.")]),e._v(" "),a("h4",{attrs:{id:"query-logic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#query-logic"}},[e._v("#")]),e._v(" Query Logic")]),e._v(" "),a("p",[e._v("We've improved the DHT query logic to more closely follow Kademlia. This should significantly speed up:")]),e._v(" "),a("ul",[a("li",[e._v("Publishing IPNS & provider records.")]),e._v(" "),a("li",[e._v("Resolving IPNS addresses.")])]),e._v(" "),a("p",[e._v("Previously, nodes would continue searching till they timed out or ran out of peers before stopping (putting or returning data found). Now, nodes will now stop as soon as they find the closest peers.")]),e._v(" "),a("h4",{attrs:{id:"routing-tables"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#routing-tables"}},[e._v("#")]),e._v(" Routing Tables")]),e._v(" "),a("p",[e._v("Finally, we've addressed the poorly maintained routing tables by:")]),e._v(" "),a("ul",[a("li",[e._v("Reducing the likelihood that the connection manager will kill connections to peers in the routing table.")]),e._v(" "),a("li",[e._v("Keeping useful peers in the routing table, even if we get disconnected from them.")]),e._v(" "),a("li",[e._v("Actively and frequently querying the DHT to keep our routing table full.")]),e._v(" "),a("li",[e._v("Prioritizing useful peers that respond to queries quickly.")])]),e._v(" "),a("h3",{attrs:{id:"testing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testing"}},[e._v("#")]),e._v(" Testing")]),e._v(" "),a("p",[e._v("The DHT rewrite was made possible by "),a("a",{attrs:{href:"https://github.com/ipfs/testground/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Testground"),a("OutboundLink")],1),e._v(", our new testing framework. Testground allows us to spin up multi-thousand node tests with simulated real-world network conditions. By combining Testground and some custom analysis tools, we were able to gain confidence that the new DHT implementation behaves correctly and significantly improves network performance.")]),e._v(" "),a("h2",{attrs:{id:"autonat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#autonat"}},[e._v("#")]),e._v(" AutoNAT")]),e._v(" "),a("p",[e._v("This release uses Automatic NAT Detection (AutoNAT) - determining if the node is "),a("em",[e._v("reachable")]),e._v(" from the public internet - to make decisions about how to participate in IPFS. This subsystem is used to determine if the node should store some of the public DHT, and if it needs to use relays to be reached by others. In short:")]),e._v(" "),a("ol",[a("li",[e._v("An AutoNAT client asks a node running an AutoNAT service if it can be reached at one of a set of guessed addresses.")]),e._v(" "),a("li",[e._v("The AutoNAT service attempts to "),a("em",[e._v("dial back")]),e._v(" those addresses, with some restrictions. We won't dial back to a different IP address, for example.")]),e._v(" "),a("li",[e._v("If the AutoNAT service succeeds, it reports back the address it successfully dialed, and the AutoNAT client knows that it is reachable from the public internet.")])]),e._v(" "),a("p",[e._v("All nodes act as AutoNAT clients to determine if they should switch into DHT server mode. As of this release, nodes will by default run the service side of AutoNAT - verifying connectivity - for up to 30 peers every minute. This service should have minimal overhead, and will be disabled for nodes in the "),a("code",[e._v("lowpower")]),e._v(" configuration profile, and those which believe they are not publicly reachable.")]),e._v(" "),a("p",[e._v("In addition to enabling the AutoNAT service by default, this release changes the AutoNAT config options:")]),e._v(" "),a("ol",[a("li",[e._v("The "),a("code",[e._v("Swarm.EnableAutoNATService")]),e._v(" option has been removed.")]),e._v(" "),a("li",[e._v("A new AutoNAT section has been added to the config. This section is empty by default.")])]),e._v(" "),a("h2",{attrs:{id:"subdomain-support-in-http-gateway"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#subdomain-support-in-http-gateway"}},[e._v("#")]),e._v(" Subdomain support in HTTP gateway")]),e._v(" "),a("p",[e._v("There are three "),a("em",[e._v("gateways")]),e._v(" for HTTP within IPFS:")]),e._v(" "),a("ol",[a("li",[e._v("Path-based")]),e._v(" "),a("li",[e._v("Subdomain-based")]),e._v(" "),a("li",[e._v("Through DNSLink")])]),e._v(" "),a("p",[e._v("Path-based gateway management is simple to implement but comes with a host of security and compatibility issues - most of these issues linked to "),a("em",[e._v("same-origin policies")]),e._v(". Under the policy, a web browser permits scripts contained in a first web page to access data in a second web page, but only if both web pages have the same "),a("em",[e._v("origin")]),e._v(".")]),e._v(" "),a("p",[e._v("Conforming to this policy was an issue before this release. There was a significant amount of "),a("em",[e._v("hackery")]),e._v(" needed to get subdomains working. With Go-IPFS 0.5, subdomains are supported straight out of the box. Users are also able to configure the gateway behavior per hostname. This implementation ensures that every application gets an individual browser origin. In summary, this update makes it easier to write websites that "),a("em",[e._v("just work")]),e._v(".")]),e._v(" "),a("p",[e._v("The gateway will now redirect from "),a("code",[e._v("localhost:5001/ipfs/CID/...")]),e._v(" to "),a("code",[e._v("CID.ipfs.localhost:5001/...")]),e._v(" by default. This ensures that every Dapp gets its own browser origin, and makes it easier to write websites because absolute paths now work. Paths addressing the gateway by IP address "),a("code",[e._v("127.0.0.1:5001/ipfs/CID")]),e._v(" will not be altered as IP addresses can't have subdomains.")]),e._v(" "),a("p",[e._v("This update to subdomain support means we'll be introducing a redirect from the path-based gateway to the correct subdomain, and doing so could cause issues with "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/CURL",target:"_blank",rel:"noopener noreferrer"}},[e._v("cURL"),a("OutboundLink")],1),e._v(", which doesn't follow redirects by default. To mitigate this issue, either change your cURL invocations to call "),a("code",[e._v("curl -L")]),e._v(", or reconfigure your IPFS node to not use the subdomain gateway on the affected domain.")]),e._v(" "),a("h2",{attrs:{id:"refactored-bitswap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refactored-bitswap"}},[e._v("#")]),e._v(" Refactored Bitswap")]),e._v(" "),a("p",[e._v("This release includes a major "),a("a",{attrs:{href:"https://blog.ipfs.io/2020-02-14-improved-bitswap-for-container-distribution/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bitswap refactor"),a("OutboundLink")],1),e._v(", running a new and backward compatible Bitswap protocol. We expect these changes to improve performance significantly.")]),e._v(" "),a("p",[e._v("With the refactored Bitswap, we expect:")]),e._v(" "),a("ul",[a("li",[e._v("Few to no duplicate blocks when fetching data from other nodes speaking the "),a("em",[e._v("new")]),e._v(" protocol.")]),e._v(" "),a("li",[e._v("Better parallelism when fetching from multiple peers.")])]),e._v(" "),a("p",[e._v("The new Bitswap won't magically make downloading content any faster until "),a("strong",[e._v("both")]),e._v(" seeds and leaches have updated. If you're one of the first to upgrade to "),a("code",[e._v("0.5.0")]),e._v(", make sure your peers upgrade as well in order to see the performance improvement.")]),e._v(" "),a("h2",{attrs:{id:"badger-integration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#badger-integration"}},[e._v("#")]),e._v(" Badger Integration")]),e._v(" "),a("p",[e._v("Badger has been in Go-IPFS for over a year as an experimental feature, and we're promoting it to stable (but not default). For this release, we've switched from writing to disk synchronously to explicitly syncing where appropriate, significantly increasing write throughput.")]),e._v(" "),a("p",[e._v("The current and default datastore used by Go-IPFS is "),a("a",{attrs:{href:"https://github.com/ipfs/go-ds-flatfs",target:"_blank",rel:"noopener noreferrer"}},[e._v("FlatFS"),a("OutboundLink")],1),e._v(". FlatFS essentially stores blocks of data as individual files on your file system. However, there are lots of optimizations a specialized database can do that a standard file system can not.")]),e._v(" "),a("p",[e._v("The benefit of Badger is that adding/fetching data to/from Badger is significantly faster than adding/fetching data to/from the default datastore, FlatFS. In some tests, adding data to Badger is 32x faster than FlatFS (in this release).")]),e._v(" "),a("h3",{attrs:{id:"enable-badger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#enable-badger"}},[e._v("#")]),e._v(" Enable Badger")]),e._v(" "),a("p",[e._v("In this release, we're marking the badger datastore as stable. However, we're not yet enabling it by default. You can enable it at initialization by running: "),a("code",[e._v("ipfs init --profile=badgerds")])]),e._v(" "),a("h3",{attrs:{id:"when-to-use-badger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#when-to-use-badger"}},[e._v("#")]),e._v(" When to use Badger")]),e._v(" "),a("p",[e._v("While Badger is a great solution, there are some issues you should consider before enabling it.")]),e._v(" "),a("p",[e._v("Badger is complicated. FlatFS pushes all the complexity down into the filesystem itself, so it's only likely to lose your data if your underlying filesystem gets corrupted. There are more opportunities for Badger itself to get corrupted.")]),e._v(" "),a("p",[e._v("Badger can use a lot of memory. In this release, we've tuned Badger to use "),a("code",[e._v("~20MB")]),e._v(" of memory by default. However, it can still produce spikes as large as "),a("a",{attrs:{href:"https://github.com/dgraph-io/badger/issues/1292",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("1GiB")]),e._v(" of data"),a("OutboundLink")],1),e._v(" in memory usage when garbage collecting.")]),e._v(" "),a("p",[e._v("Finally, badger isn't very aggressive when it comes to garbage collection, and we're still investigating ways to get it to more aggressively clean up after itself.")]),e._v(" "),a("p",[e._v("We suggest you use Badger if:")]),e._v(" "),a("ul",[a("li",[e._v("Performance is your main requirement.")]),e._v(" "),a("li",[e._v("You rarely delete anything.")]),e._v(" "),a("li",[e._v("You have some memory to spare.")])]),e._v(" "),a("h2",{attrs:{id:"tls-by-default"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tls-by-default"}},[e._v("#")]),e._v(" TLS by default")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Transport_Layer_Security",target:"_blank",rel:"noopener noreferrer"}},[e._v("Transport layer security"),a("OutboundLink")],1),e._v(" (TLS), is a set of technologies used for link-layer encryption. It's a commonly used technology; most of the web browsing you do every day uses TLS. Using TLS by default provides a robust set of encryption and authentication standards. In this release, we're switching TLS to be the default transport. This means we'll try to encrypt the connection with TLS before re-trying with SECIO. SECIO will be deprecated in an upcoming next release.")]),e._v(" "),a("h2",{attrs:{id:"ethdns-support-for-eth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ethdns-support-for-eth"}},[e._v("#")]),e._v(" EthDNS support for "),a("code",[e._v(".eth")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://ens.domains/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ethereum Name Service"),a("OutboundLink")],1),e._v(" (ENS) offers a secure and decentralized way to address resources both on and off the blockchain using simple, human-readable domain names. This means you can use ENS to map domain names like "),a("code",[e._v("RandomPlanetFacts.eth")]),e._v(" to IPFS content paths, for example "),a("code",[e._v("/ipfs/QmW7S5HRLkP4XtPNyT1vQSjP3eRdtZaVtF6FAPvUfduMjA")]),e._v(".")]),e._v(" "),a("p",[e._v("EthDNS is a way to access information in the Ethereum Name Service from DNS, without running a local Ethereum client. "),a("a",{attrs:{href:"https://eth.link",target:"_blank",rel:"noopener noreferrer"}},[e._v("Eth.link"),a("OutboundLink")],1),e._v(" is a public EthDNS instance created to resolve ENS records behind "),a("code",[e._v(".eth")]),e._v(" domains. Because "),a("code",[e._v(".eth")]),e._v(" is not a registered DNS top-level domain, it is normally inaccessible through regular browsers. But with EthDNS you can view ENS websites by adding "),a("code",[e._v(".link")]),e._v(" to the end of the URL. A DNS "),a("code",[e._v("A")]),e._v(" record request for "),a("code",[e._v("RandomPlanetFacts.eth.link")]),e._v(" looks up the "),a("code",[e._v("A")]),e._v(" records in ENS for "),a("code",[e._v("RandomPlanetFacts.eth")]),e._v(".")]),e._v(" "),a("p",[e._v("Go-IPFS 0.5 supports the resolution of DNSLink for "),a("code",[e._v(".eth")]),e._v(" names through the EthDNS instance at "),a("a",{attrs:{href:"https://eth.link",target:"_blank",rel:"noopener noreferrer"}},[e._v("eth.link"),a("OutboundLink")],1),e._v(" transparently, which means you can use "),a("code",[e._v("/ipns/RandomPlanetFacts.eth")]),e._v(" within IPFS without having to add "),a("code",[e._v(".link")]),e._v(" to the end of the URL:")]),e._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[e._v("ipfs resolve -r /ipns/RandomPlanetFacts.eth\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" /ipfs/QmW7S5HRLkP4XtPNyT1vQSjP3eRdtZaVtF6FAPvUfduMjA\n")])])]),a("h2",{attrs:{id:"systemd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#systemd"}},[e._v("#")]),e._v(" Systemd")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Systemd",target:"_blank",rel:"noopener noreferrer"}},[e._v("Systemd"),a("OutboundLink")],1),e._v(" has become a ubiquitous initialization system for Linux distributions. Among its many functions, it provides a standard mechanism for managing background processes - the various servers and tasks that run on your machine. IPFS for Linux now plugs into the Systemd world, allowing it to start automatically with the computer. This support also allows IPFS to be controlled through the same interface as the other programs running on your computer. This makes it possible to:")]),e._v(" "),a("ul",[a("li",[e._v("Start IPFS on-demand on first use.")]),e._v(" "),a("li",[e._v("Wait for IPFS to finish starting before starting services that depend on it.")])]),e._v(" "),a("p",[e._v("You can find the new systemd units in the "),a("a",{attrs:{href:"https://github.com/ipfs/go-ipfs",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("ipfs/go-ipfs")]),e._v(" repository"),a("OutboundLink")],1),e._v(" under "),a("a",{attrs:{href:"https://github.com/ipfs/go-ipfs/tree/master/misc/systemd",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("misc/systemd")]),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"testground"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testground"}},[e._v("#")]),e._v(" Testground")]),e._v(" "),a("p",[e._v("Testground is a new testing framework that IPFS is using to validate the changes to the distributed aspects of the system. Complex changes, like the DHT, are challenging to understand through unit tests or with a small number of machines. Testground provides the ability to spin up thousands of virtual IPFS nodes in complex network topologies to gain confidence that changes will work when they're rolled out. With Testground, expect more stability and regularity in upcoming IPFS releases.")])])}),[],!1,null,null,null);t.default=o.exports}}]);