(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{438:function(e,t,a){"use strict";a.r(t);var s=a(18),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"hashing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashing"}},[e._v("#")]),e._v(" Hashing")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("If you're interested in how cryptographic hashes fit into how IPFS works with files in general, check out this video from IPFS Camp 2019! "),a("a",{attrs:{href:"https://www.youtube.com/watch?v=Z5zNPwMDYGg",target:"_blank",rel:"noopener noreferrer"}},[e._v("Core Course: How IPFS Deals With Files"),a("OutboundLink")],1)])]),e._v(" "),a("p",[e._v("Cryptographic hashes are functions that take some arbitrary input and return a fixed-length value. The particular value depends on the given hash algorithm in use, such as "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/SHA-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("SHA-1"),a("OutboundLink")],1),e._v(" (used by git), "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/SHA-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("SHA-256"),a("OutboundLink")],1),e._v(", or "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2",target:"_blank",rel:"noopener noreferrer"}},[e._v("BLAKE2"),a("OutboundLink")],1),e._v(", but a given hash algorithm always returns the same value for a given input. Have a look at Wikipedia's "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/List_of_hash_functions",target:"_blank",rel:"noopener noreferrer"}},[e._v("full list of hash functions"),a("OutboundLink")],1),e._v(" for more.")]),e._v(" "),a("p",[e._v("As an example, the input:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Hello world\n")])])]),a("p",[e._v("would be represented by "),a("strong",[e._v("SHA-1")]),e._v(" as:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("0x7B502C3A1F48C8609AE212CDFB639DEE39673F5E\n")])])]),a("p",[e._v("However, the exact same input generates the following output using "),a("strong",[e._v("SHA-256")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("0x64EC88CA00B268E5BA1A35678A1B5316D212F4F366B2477232534A8AECA37F3C\n")])])]),a("p",[e._v("Notice that the second hash is longer than the first one. This is because SHA-1 creates a 160 bit hash, while SHA-256 creates a 256 bit hash. Also, the prepended "),a("code",[e._v("0x")]),e._v(" is just an indicator that tells us that the following hash is represented as a base 16 (or hexadecimal) number.")]),e._v(" "),a("p",[e._v("Hashes can be represented in different bases ("),a("code",[e._v("base2")]),e._v(", "),a("code",[e._v("base16")]),e._v(", "),a("code",[e._v("base32")]),e._v(", etc.). In fact, IPFS makes use of that as part of its "),a("RouterLink",{attrs:{to:"/concepts/content-addressing/"}},[e._v("content identifiers")]),e._v(" and supports multiple base representations at the same time, using the "),a("a",{attrs:{href:"https://github.com/multiformats/multibase",target:"_blank",rel:"noopener noreferrer"}},[e._v("Multibase"),a("OutboundLink")],1),e._v(" protocol.")],1),e._v(" "),a("p",[e._v('For example, the SHA-256 hash of "Hello world" from above can be represented as base 32 as:')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("mtwirsqawjuoloq2gvtyug2tc3jbf5htm2zeo4rsknfiv3fdp46a\n")])])]),a("h2",{attrs:{id:"hashes-are-important"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashes-are-important"}},[e._v("#")]),e._v(" Hashes are important")]),e._v(" "),a("p",[e._v("Cryptographic hashes come with a couple of very important characteristics:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("deterministic")]),e._v(" - the same input message always returns exactly the same output hash")]),e._v(" "),a("li",[a("strong",[e._v("uncorrelated")]),e._v(" - a small change in the message should generate a completely different hash")]),e._v(" "),a("li",[a("strong",[e._v("unique")]),e._v(" - it's infeasible to generate the same hash from two different messages")]),e._v(" "),a("li",[a("strong",[e._v("one-way")]),e._v(" - it's infeasible to guess or calculate the input message from its hash")])]),e._v(" "),a("p",[e._v("It turns out these features also mean we can use a cryptographic hash to identify any piece of data: the hash is unique to the data we calculated it from and it’s not too long (a hash is a fixed length, so the SHA-256 hash of a one-gigabyte video file is still only 32 bytes), so sending it around the network doesn't take up a lot of resources.")]),e._v(" "),a("p",[e._v("That's critical for a distributed system like IPFS, where we want to be able to store and retrieve data from many places. A computer running IPFS can ask all the peers it's connected to whether they have a file with a particular hash and, if one of them does, they send back the whole file. Without a short, unique identifier like a cryptographic hash, that wouldn't be possible. This technique is called "),a("RouterLink",{attrs:{to:"/concepts/content-addressing/"}},[e._v("content addressing")]),e._v(" — because the content itself is used to form an address, rather than information about the computer and disk location it's stored at.")],1)])}),[],!1,null,null,null);t.default=r.exports}}]);